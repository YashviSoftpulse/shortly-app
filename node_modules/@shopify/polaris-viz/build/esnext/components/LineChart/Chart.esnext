import { useState, useRef, Fragment } from 'react';
import { DEFAULT_THEME_NAME, useTheme, useChartContext, LINE_HEIGHT, COLOR_VISION_SINGLE_ITEM, uniqueId, useYScale, useChartPositions, LineSeries, DataType, ChartMargin, clamp } from '@shopify/polaris-viz-core';
import { useIndexForLabels } from '../../hooks/useIndexForLabels.esnext';
import { useFormattedLabels } from '../../hooks/useFormattedLabels.esnext';
import { Y_AXIS_LABEL_OFFSET, ANNOTATIONS_LABELS_OFFSET, CROSSHAIR_ID } from '../../constants.esnext';
import { ChartElements } from '../ChartElements/index.esnext';
import { useLineChartTooltipContent } from './hooks/useLineChartTooltipContent.esnext';
import { jsxs, jsx } from 'react/jsx-runtime';
import { useColorVisionEvents } from '../../hooks/ColorVisionA11y/useColorVisionEvents.esnext';
import { useLegend } from '../LegendContainer/hooks/useLegend.esnext';
import { useWatchColorVisionEvents } from '../../hooks/ColorVisionA11y/useWatchColorVisionEvents.esnext';
import { useExternalHideEvents } from '../../hooks/ExternalEvents/useExternalHideEvents.esnext';
import { yAxisMinMax } from './utilities/yAxisMinMax.esnext';
import { useFormatData } from './hooks/useFormatData.esnext';
import { useLinearLabelsAndDimensions } from '../../hooks/useLinearLabelsAndDimensions.esnext';
import { checkAvailableAnnotations } from '../Annotations/utilities/checkAvailableAnnotations.esnext';
import { XAxis } from '../XAxis/XAxis.esnext';
import { HorizontalGridLines } from '../HorizontalGridLines/HorizontalGridLines.esnext';
import { YAxis } from '../YAxis/YAxis.esnext';
import { VisuallyHiddenRows } from '../VisuallyHiddenRows/VisuallyHiddenRows.esnext';
import { PointsAndCrosshair } from './components/PointsAndCrosshair/PointsAndCrosshair.esnext';
import { Annotations } from '../Annotations/Annotations.esnext';
import { YAxisAnnotations } from '../Annotations/YAxisAnnotations.esnext';
import { TooltipWrapper } from '../TooltipWrapper/TooltipWrapper.esnext';
import { getAlteredLineChartPosition } from './utilities/getAlteredLineChartPosition.esnext';
import { LegendContainer } from '../LegendContainer/LegendContainer.esnext';
import { eventPointNative } from '../../utilities/eventPoint.esnext';
import { TOOLTIP_POSITION_DEFAULT_RETURN } from '../TooltipWrapper/constants.esnext';

function Chart({
  annotationsLookupTable,
  emptyStateText,
  data,
  dimensions,
  renderLegendContent,
  renderTooltipContent,
  renderHiddenLegendLabel,
  seriesNameFormatter,
  showLegend = true,
  hideLegendOverflow = true,
  slots,
  theme = DEFAULT_THEME_NAME,
  xAxisOptions,
  yAxisOptions
}) {
  var _dimensions$x2, _dimensions$y2, _slots$chart;

  useColorVisionEvents({
    enabled: data.length > 1,
    dimensions
  });
  const selectedTheme = useTheme(theme);
  const {
    isPerformanceImpacted
  } = useChartContext();
  const [activeIndex, setActiveIndex] = useState(null);
  const [activeLineIndex, setActiveLineIndex] = useState(-1);
  const [xAxisHeight, setXAxisHeight] = useState(LINE_HEIGHT);
  const [annotationsHeight, setAnnotationsHeight] = useState(0);
  const {
    legend,
    setLegendDimensions,
    height,
    width
  } = useLegend({
    data: [{
      shape: 'Line',
      series: data
    }],
    dimensions,
    showLegend,
    seriesNameFormatter
  });
  useWatchColorVisionEvents({
    type: COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => setActiveLineIndex(detail.index)
  });
  const {
    hiddenIndexes: hiddenLineIndexes
  } = useExternalHideEvents();
  const indexForLabels = useIndexForLabels(data);
  const {
    formattedLabels,
    unformattedLabels
  } = useFormattedLabels({
    data: [data[indexForLabels]],
    labelFormatter: xAxisOptions.labelFormatter
  });
  const tooltipId = useRef(uniqueId('lineChart'));
  const [svgRef, setSvgRef] = useState(null);
  const emptyState = data.length === 0 || data.every(series => series.data.length === 0);
  const {
    minY,
    maxY
  } = yAxisMinMax(data);
  const yScaleOptions = {
    formatYAxisLabel: yAxisOptions.labelFormatter,
    integersOnly: yAxisOptions.integersOnly,
    fixedWidth: yAxisOptions.fixedWidth,
    maxYOverride: yAxisOptions.maxYOverride,
    max: maxY,
    min: minY
  };
  const {
    yAxisLabelWidth
  } = useYScale({ ...yScaleOptions,
    drawableHeight: height,
    verticalOverflow: selectedTheme.grid.verticalOverflow
  });
  const {
    longestSeriesLength,
    longestSeriesIndex
  } = useFormatData(data);
  const {
    drawableWidth,
    drawableHeight,
    chartXPosition,
    chartYPosition,
    xAxisBounds,
    yAxisBounds
  } = useChartPositions({
    annotationsHeight,
    height,
    width,
    xAxisHeight,
    yAxisWidth: yAxisLabelWidth
  });
  const hideXAxis = xAxisOptions.hide || selectedTheme.xAxis.hide;
  const {
    xAxisDetails,
    xScale,
    labels
  } = useLinearLabelsAndDimensions({
    data,
    drawableWidth,
    hideXAxis,
    labels: formattedLabels,
    longestSeriesLength
  });
  const {
    ticks,
    yScale
  } = useYScale({ ...yScaleOptions,
    drawableHeight,
    verticalOverflow: selectedTheme.grid.verticalOverflow
  });
  const annotationsDrawableHeight = chartYPosition + drawableHeight + ANNOTATIONS_LABELS_OFFSET;
  const getTooltipMarkup = useLineChartTooltipContent({
    data,
    renderTooltipContent,
    indexForLabels,
    hiddenIndexes: hiddenLineIndexes,
    seriesNameFormatter
  });

  if (xScale == null || drawableWidth == null || yAxisLabelWidth == null) {
    return null;
  }

  function getTooltipPosition({
    event,
    index,
    eventType
  }) {
    if (eventType === 'mouse') {
      const point = eventPointNative(event);

      if (point == null || xScale == null || data[longestSeriesIndex] == null) {
        return TOOLTIP_POSITION_DEFAULT_RETURN;
      }

      const {
        svgX
      } = point;
      const closestIndex = Math.round(xScale.invert(svgX - chartXPosition));
      const activeIndex = clamp({
        amount: closestIndex,
        min: 0,
        max: data[longestSeriesIndex].data.length - 1
      });
      return {
        x: event.pageX,
        y: event.pageY,
        activeIndex
      };
    } else {
      var _xScale, _dimensions$x, _dimensions$y;

      const activeIndex = index !== null && index !== void 0 ? index : 0;
      const x = (_xScale = xScale === null || xScale === void 0 ? void 0 : xScale(activeIndex)) !== null && _xScale !== void 0 ? _xScale : 0;
      return {
        x: x + ((_dimensions$x = dimensions === null || dimensions === void 0 ? void 0 : dimensions.x) !== null && _dimensions$x !== void 0 ? _dimensions$x : 0),
        y: (_dimensions$y = dimensions === null || dimensions === void 0 ? void 0 : dimensions.y) !== null && _dimensions$y !== void 0 ? _dimensions$y : 0,
        activeIndex
      };
    }
  }

  function moveCrosshair(index) {
    setActiveIndex(0);

    if (index == null) {
      return;
    }

    const crosshair = document.getElementById(`${tooltipId.current}-${CROSSHAIR_ID}`);

    if (crosshair == null) {
      return;
    }

    crosshair.setAttribute('x', `${xScale(index) - selectedTheme.crossHair.width / 2}`);
  }

  const chartBounds = {
    width,
    height,
    x: (_dimensions$x2 = dimensions === null || dimensions === void 0 ? void 0 : dimensions.x) !== null && _dimensions$x2 !== void 0 ? _dimensions$x2 : chartXPosition,
    y: (_dimensions$y2 = dimensions === null || dimensions === void 0 ? void 0 : dimensions.y) !== null && _dimensions$y2 !== void 0 ? _dimensions$y2 : chartYPosition
  };
  const {
    hasXAxisAnnotations,
    hasYAxisAnnotations
  } = checkAvailableAnnotations(annotationsLookupTable);
  const halfXAxisLabelWidth = xAxisDetails.labelWidth / 2;
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsxs(ChartElements.Svg, {
      emptyState: emptyState,
      emptyStateText: emptyStateText,
      height: height,
      role: "table",
      setRef: setSvgRef,
      width: width,
      children: [hideXAxis ? null : /*#__PURE__*/jsx(XAxis, {
        allowLineWrap: xAxisOptions.allowLineWrap,
        ariaHidden: true,
        isLinearChart: true,
        labels: labels,
        labelWidth: xAxisDetails.labelWidth,
        onHeightChange: setXAxisHeight,
        reducedLabelIndexes: xAxisDetails.reducedLabelIndexes,
        x: xAxisBounds.x - halfXAxisLabelWidth,
        xScale: xScale,
        y: xAxisBounds.y
      }), selectedTheme.grid.showHorizontalLines ? /*#__PURE__*/jsx(HorizontalGridLines, {
        ticks: ticks,
        transform: {
          x: selectedTheme.grid.horizontalOverflow ? 0 : chartXPosition,
          y: chartYPosition
        },
        width: selectedTheme.grid.horizontalOverflow ? width : drawableWidth
      }) : null, /*#__PURE__*/jsx(YAxis, {
        ticks: ticks,
        width: yAxisLabelWidth + Y_AXIS_LABEL_OFFSET,
        textAlign: "right",
        ariaHidden: true,
        x: yAxisBounds.x,
        y: yAxisBounds.y
      }), emptyState ? null : /*#__PURE__*/jsx(VisuallyHiddenRows, {
        data: data,
        formatYAxisLabel: yAxisOptions.labelFormatter,
        xAxisLabels: labels
      }), /*#__PURE__*/jsxs("g", {
        transform: `translate(${chartXPosition},${chartYPosition})`,
        children: [slots === null || slots === void 0 ? void 0 : (_slots$chart = slots.chart) === null || _slots$chart === void 0 ? void 0 : _slots$chart.call(slots, {
          yScale,
          xScale,
          drawableWidth,
          drawableHeight,
          theme
        }), data.map((singleSeries, index) => {
          var _singleSeries$metadat;

          if (((_singleSeries$metadat = singleSeries.metadata) === null || _singleSeries$metadat === void 0 ? void 0 : _singleSeries$metadat.isVisuallyHidden) === true) {
            return null;
          }

          return /*#__PURE__*/jsx(LineSeries, {
            activeLineIndex: activeLineIndex,
            data: singleSeries,
            hiddenIndexes: hiddenLineIndexes,
            index: index,
            svgDimensions: {
              height: drawableHeight,
              width: drawableWidth
            },
            theme: theme,
            xScale: xScale,
            yScale: yScale,
            type: "default"
          }, `${name}-${index}`);
        }), /*#__PURE__*/jsx(PointsAndCrosshair, {
          activeIndex: activeIndex,
          data: data,
          drawableHeight: drawableHeight,
          emptyState: emptyState,
          hiddenIndexes: hiddenLineIndexes,
          longestSeriesIndex: longestSeriesIndex,
          theme: theme,
          tooltipId: tooltipId.current,
          xScale: xScale,
          yScale: yScale
        })]
      }), hasXAxisAnnotations && /*#__PURE__*/jsx("g", {
        transform: `translate(${chartXPosition},0)`,
        tabIndex: -1,
        children: /*#__PURE__*/jsx(Annotations, {
          annotationsLookupTable: annotationsLookupTable,
          axisLabelWidth: xAxisDetails.labelWidth,
          drawableHeight: annotationsDrawableHeight,
          drawableWidth: drawableWidth,
          labels: unformattedLabels,
          onHeightChange: setAnnotationsHeight,
          xScale: xScale
        })
      }), hasYAxisAnnotations && /*#__PURE__*/jsx("g", {
        transform: `translate(${chartXPosition},${chartYPosition})`,
        tabIndex: -1,
        children: /*#__PURE__*/jsx(YAxisAnnotations, {
          annotationsLookupTable: annotationsLookupTable,
          drawableHeight: annotationsDrawableHeight,
          drawableWidth: drawableWidth,
          ticks: ticks,
          yScale: yScale
        })
      })]
    }), longestSeriesLength !== -1 && /*#__PURE__*/jsx(TooltipWrapper, {
      alwaysUpdatePosition: true,
      chartBounds: chartBounds,
      focusElementDataType: DataType.Point,
      getAlteredPosition: getAlteredLineChartPosition,
      getMarkup: getTooltipMarkup,
      getPosition: getTooltipPosition,
      id: tooltipId.current,
      margin: ChartMargin,
      onIndexChange: index => {
        if (index != null && isPerformanceImpacted) {
          moveCrosshair(index);
        } else {
          setActiveIndex(index);
        }
      },
      parentRef: svgRef,
      usePortal: true
    }), showLegend && /*#__PURE__*/jsx(LegendContainer, {
      colorVisionType: COLOR_VISION_SINGLE_ITEM,
      data: legend,
      onDimensionChange: setLegendDimensions,
      renderLegendContent: renderLegendContent,
      renderHiddenLegendLabel: renderHiddenLegendLabel,
      dimensions: dimensions,
      enableHideOverflow: hideLegendOverflow
    })]
  });
}

export { Chart };
