import { useMemo, useCallback, Fragment } from 'react';
import { useChartContext, useTheme, COLOR_VISION_SINGLE_ITEM, clamp, uniqueId, DataType, MASK_HIGHLIGHT_COLOR, BAR_SPACING, LinearGradientWithStops, SHAPE_ANIMATION_HEIGHT_BUFFER, getColorVisionEventAttrs, COLOR_VISION_GROUP_ITEM } from '@shopify/polaris-viz-core';
import { getChartId } from '../../../../utilities/getChartId.esnext';
import { applyColorVisionToDomElement } from '../../../../utilities/applyColorVisionToDomElement.esnext';
import styles from './BarGroup.scss.esnext';
import { jsxs, jsx } from 'react/jsx-runtime';
import { formatAriaLabel } from '../../utilities/formatAriaLabel.esnext';
import { useWatchColorVisionEvents } from '../../../../hooks/ColorVisionA11y/useWatchColorVisionEvents.esnext';
import { VerticalBar } from '../VerticalBar/VerticalBar.esnext';
import { getHoverZoneOffset } from '../../../../utilities/getHoverZoneOffset.esnext';

const COLOR_VISION_MASK = 'colorVisionMask';
function BarGroup({
  animationDelay,
  x,
  data,
  yScale,
  width,
  colors,
  drawableHeight,
  indexOffset,
  barGroupIndex,
  accessibilityData,
  activeBarGroup,
  gapWidth,
  theme,
  areAllNegative
}) {
  const groupAriaLabel = formatAriaLabel(accessibilityData[barGroupIndex]);
  const {
    id,
    isPerformanceImpacted
  } = useChartContext();
  const selectedTheme = useTheme(theme);
  const maskItems = useMemo(() => {
    const chart = document.getElementById(getChartId(id));

    if (chart == null) {
      return [];
    }

    return chart.querySelectorAll(`[data-type="${COLOR_VISION_MASK}"][data-group-index="${barGroupIndex}"]`); // We want this to run whenever colors change so we
    // get all the mask items again.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [colors]);
  useWatchColorVisionEvents({
    type: COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => {
      if (detail.index === -1 || activeBarGroup === -1 || activeBarGroup === barGroupIndex) {
        maskItems.forEach(element => {
          applyColorVisionToDomElement({
            element,
            activeIndex: detail.index,
            isPerformanceImpacted
          });
        });
      }
    }
  });
  const dataLength = clamp({
    amount: data.length,
    min: 1,
    max: Infinity
  });
  const barWidth = width / dataLength;
  const getBarHeight = useCallback(rawValue => {
    return Math.abs(yScale(rawValue) - yScale(0));
  }, [yScale]);
  const gradientId = useMemo(() => uniqueId('gradient'), []);
  const maskId = useMemo(() => uniqueId('mask'), []);
  const gradients = colors.map(color => {
    return typeof color === 'string' ? [{
      color,
      offset: 0
    }] : color;
  });
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx("mask", {
      id: maskId,
      children: data.map((rawValue, index) => {
        if (rawValue == null) {
          return null;
        }

        return /*#__PURE__*/jsx("g", {
          className: styles.BarGroup,
          "data-type": DataType.BarGroup,
          "data-index": barGroupIndex,
          children: /*#__PURE__*/jsx(VerticalBar, {
            height: getBarHeight(rawValue),
            color: MASK_HIGHLIGHT_COLOR,
            x: x + (barWidth + BAR_SPACING) * index,
            zeroPosition: yScale(0),
            rawValue: rawValue,
            width: barWidth,
            index: index,
            animationDelay: animationDelay,
            areAllNegative: areAllNegative
          })
        }, `${barGroupIndex}${index}`);
      })
    }), /*#__PURE__*/jsx("g", {
      mask: `url(#${maskId})`,
      children: gradients.map((gradient, index) => {
        return /*#__PURE__*/jsxs("g", {
          children: [/*#__PURE__*/jsx(LinearGradientWithStops, {
            gradient: gradient,
            id: `${gradientId}${index}`
          }), /*#__PURE__*/jsx("rect", {
            x: x + (barWidth + BAR_SPACING) * index,
            y: SHAPE_ANIMATION_HEIGHT_BUFFER * -1,
            width: barWidth - BAR_SPACING,
            height: drawableHeight + SHAPE_ANIMATION_HEIGHT_BUFFER * 2,
            "data-type": COLOR_VISION_MASK,
            "data-index": index,
            "data-group-index": barGroupIndex,
            fill: data[index] === 0 ? selectedTheme.bar.zeroValueColor : `url(#${gradientId}${index})`
          })]
        }, `${maskId}${index}`);
      })
    }), /*#__PURE__*/jsxs("g", { ...getColorVisionEventAttrs({
        type: COLOR_VISION_GROUP_ITEM,
        index: barGroupIndex
      }),
      className: styles.BarGroup,
      "data-type": DataType.BarGroup,
      "data-index": barGroupIndex,
      "aria-hidden": "false",
      "aria-label": groupAriaLabel,
      role: "list",
      children: [/*#__PURE__*/jsx("rect", {
        width: barWidth * dataLength + gapWidth,
        x: x - gapWidth / 2,
        height: drawableHeight,
        fill: "transparent",
        "aria-hidden": "true"
      }), data.map((rawValue, index) => {
        if (rawValue === null) {
          return null;
        }

        const {
          label,
          value
        } = accessibilityData[barGroupIndex].data[index];
        const ariaLabel = `${label} ${value}`;
        const height = clamp({
          amount: Math.abs(yScale(rawValue) - yScale(0)),
          min: 1,
          max: Infinity
        });
        const isNegative = rawValue < 0;
        const y = isNegative ? yScale(0) : yScale(0) - height;
        const {
          clampedSize,
          offset
        } = getHoverZoneOffset({
          barSize: height,
          zeroPosition: yScale(0),
          max: drawableHeight,
          position: 'vertical'
        });
        return /*#__PURE__*/jsx("rect", {
          height: clampedSize,
          x: x + barWidth * index,
          y: isNegative || areAllNegative ? y : y - offset,
          width: barWidth,
          fill: "transparent",
          "aria-label": ariaLabel,
          role: "listitem",
          ...getColorVisionEventAttrs({
            type: COLOR_VISION_SINGLE_ITEM,
            index: index + indexOffset,
            watch: !isPerformanceImpacted
          }),
          className: styles.Bar,
          tabIndex: -1
        }, index);
      })]
    })]
  });
}

export { BarGroup };
