import { useChartContext, DataType, COLOR_VISION_GROUP_ITEM } from '@shopify/polaris-viz-core';
import { useState, useMemo, Fragment } from 'react';
import { getLoadAnimationDelay } from '../../../../utilities/getLoadAnimationDelay.esnext';
import { getChartId } from '../../../../utilities/getChartId.esnext';
import { applyColorVisionToDomElement } from '../../../../utilities/applyColorVisionToDomElement.esnext';
import { jsx } from 'react/jsx-runtime';
import { useWatchColorVisionEvents } from '../../../../hooks/ColorVisionA11y/useWatchColorVisionEvents.esnext';
import { StackedBarGroups } from '../StackedBarGroups/StackedBarGroups.esnext';
import { BarGroup } from '../BarGroup/BarGroup.esnext';

function VerticalBarGroup({
  colors,
  data,
  drawableHeight,
  gapWidth,
  id,
  indexOffset = 0,
  labels,
  sortedData,
  stackedValues,
  xScale,
  yScale,
  yAxisOptions,
  areAllNegative
}) {
  const {
    id: chartId,
    isPerformanceImpacted
  } = useChartContext();
  const [activeBarGroup, setActiveBarGroup] = useState(-1);
  const groupElements = useMemo(() => {
    const chart = document.getElementById(getChartId(chartId));

    if (chart == null) {
      return [];
    }

    return chart.querySelectorAll(`[data-type="${DataType.BarGroup}"]`); // We want this to run whenever colors change so we
    // get all the groups again.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [sortedData]);
  useWatchColorVisionEvents({
    type: COLOR_VISION_GROUP_ITEM,
    onIndexChange: ({
      detail
    }) => {
      setActiveBarGroup(detail.index);
      groupElements.forEach(element => {
        applyColorVisionToDomElement({
          element,
          activeIndex: detail.index,
          isPerformanceImpacted
        });
      });
    }
  });
  const accessibilityData = useMemo(() => labels.map((title, index) => {
    const content = data.map(({
      data,
      name
    }) => {
      var _data$index$value;

      return {
        label: name !== null && name !== void 0 ? name : '',
        value: yAxisOptions.labelFormatter((_data$index$value = data[index].value) !== null && _data$index$value !== void 0 ? _data$index$value : 0)
      };
    });
    return {
      title,
      data: content
    };
  }), [data, labels, yAxisOptions]);

  if (stackedValues != null) {
    return /*#__PURE__*/jsx(StackedBarGroups, {
      accessibilityData: accessibilityData,
      activeBarGroup: activeBarGroup,
      colors: colors,
      drawableHeight: drawableHeight,
      gapWidth: gapWidth,
      id: id,
      labels: labels,
      stackedValues: stackedValues,
      xScale: xScale,
      yScale: yScale
    });
  }

  return /*#__PURE__*/jsx(Fragment, {
    children: sortedData.map((item, index) => {
      const xPosition = xScale(index.toString());
      const animationDelay = getLoadAnimationDelay(index, sortedData.length);
      return /*#__PURE__*/jsx(BarGroup, {
        accessibilityData: accessibilityData,
        activeBarGroup: activeBarGroup,
        animationDelay: animationDelay,
        barGroupIndex: index,
        colors: colors,
        data: item,
        gapWidth: gapWidth,
        drawableHeight: drawableHeight,
        indexOffset: indexOffset,
        width: xScale.bandwidth(),
        x: xPosition == null ? 0 : xPosition,
        yScale: yScale,
        areAllNegative: areAllNegative
      }, index);
    })
  });
}

export { VerticalBarGroup };
