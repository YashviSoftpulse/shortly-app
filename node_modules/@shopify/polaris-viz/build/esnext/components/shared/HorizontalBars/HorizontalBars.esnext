import { useState, Fragment } from 'react';
import { useTheme, useChartContext, COLOR_VISION_SINGLE_ITEM, HORIZONTAL_GROUP_LABEL_HEIGHT, estimateStringWidth, HORIZONTAL_BAR_LABEL_OFFSET, HORIZONTAL_SPACE_BETWEEN_SINGLE, getColorVisionEventAttrs, clamp } from '@shopify/polaris-viz-core';
import { getTrendIndicatorData } from '../../../utilities/getTrendIndicatorData.esnext';
import styles from './HorizontalBars.scss.esnext';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useWatchColorVisionEvents } from '../../../hooks/ColorVisionA11y/useWatchColorVisionEvents.esnext';
import { getHoverZoneOffset } from '../../../utilities/getHoverZoneOffset.esnext';
import { Bar } from '../Bar/Bar.esnext';
import { getGradientDefId } from '../GradientDefs/GradientDefs.esnext';
import { LabelWrapper } from '../LabelWrapper/LabelWrapper.esnext';
import { Label } from '../Label/Label.esnext';
import { TrendIndicator } from '../../TrendIndicator/TrendIndicator.esnext';
import { HEIGHT } from '../../TrendIndicator/constants.esnext';

const SERIES_DELAY = 150;
function HorizontalBars({
  activeGroupIndex,
  animationDelay = 0,
  barHeight,
  data,
  groupIndex,
  id,
  isSimple,
  labelFormatter,
  name,
  xScale,
  zeroPosition,
  containerWidth,
  areAllNegative
}) {
  const selectedTheme = useTheme();
  const {
    characterWidths,
    theme
  } = useChartContext();
  const [activeBarIndex, setActiveBarIndex] = useState(-1);
  useWatchColorVisionEvents({
    type: COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => {
      if (activeGroupIndex === -1 || activeGroupIndex === groupIndex) {
        setActiveBarIndex(detail.index);
      }
    }
  });
  return /*#__PURE__*/jsx("g", {
    transform: `translate(${zeroPosition},${HORIZONTAL_GROUP_LABEL_HEIGHT})`,
    "aria-hidden": "true",
    children: data.map((_, seriesIndex) => {
      var _data$seriesIndex, _data$seriesIndex$met;

      if (data[seriesIndex].data[groupIndex] == null) {
        return;
      }

      const seriesAnimationDelay = animationDelay + SERIES_DELAY * seriesIndex;
      const {
        value
      } = data[seriesIndex].data[groupIndex];

      if (value == null) {
        return null;
      }

      const isNegative = value && value < 0;
      const label = labelFormatter(value);
      const ariaLabel = `${data[seriesIndex] ? data[seriesIndex].name : ''} ${value}`;
      const {
        trendIndicatorProps,
        trendIndicatorWidth
      } = getTrendIndicatorData((_data$seriesIndex = data[seriesIndex]) === null || _data$seriesIndex === void 0 ? void 0 : (_data$seriesIndex$met = _data$seriesIndex.metadata) === null || _data$seriesIndex$met === void 0 ? void 0 : _data$seriesIndex$met.trends[groupIndex]);
      const labelWidth = estimateStringWidth(`${label}`, characterWidths);

      function getBarWidthAndLabelX() {
        const width = Math.abs(xScale(value !== null && value !== void 0 ? value : 0) - xScale(0));
        const itemSpacing = trendIndicatorProps == null ? HORIZONTAL_BAR_LABEL_OFFSET : HORIZONTAL_BAR_LABEL_OFFSET * 2;
        const leftLabelOffset = isSimple ? labelWidth + itemSpacing + trendIndicatorWidth : 0;
        const clampedWidth = clamp({
          amount: width,
          min: 1,
          max: Infinity
        });

        if (isNegative) {
          return {
            labelX: -(clampedWidth + leftLabelOffset),
            barWidth: clampedWidth
          };
        }

        return {
          labelX: clampedWidth + HORIZONTAL_BAR_LABEL_OFFSET,
          barWidth: clampedWidth
        };
      }

      const {
        labelX,
        barWidth
      } = getBarWidthAndLabelX();
      const y = barHeight * seriesIndex + HORIZONTAL_SPACE_BETWEEN_SINGLE * seriesIndex;
      const {
        clampedSize
      } = getHoverZoneOffset({
        barSize: barWidth,
        zeroPosition: xScale(0),
        max: containerWidth,
        position: 'horizontal'
      });
      const trendYOffset = (barHeight - HEIGHT) / 2;
      return /*#__PURE__*/jsxs(Fragment, {
        children: [/*#__PURE__*/jsx(Bar, {
          animationDelay: seriesAnimationDelay,
          areAllNegative: areAllNegative,
          color: `url(#${getGradientDefId(theme, seriesIndex, id)})`,
          height: barHeight,
          index: groupIndex,
          isActive: activeBarIndex === -1 || activeBarIndex === seriesIndex,
          transform: isNegative ? 'scaleX(-1)' : '',
          width: barWidth,
          x: 0,
          y: y
        }), isSimple && /*#__PURE__*/jsxs(LabelWrapper, {
          animationDelay: seriesAnimationDelay,
          x: labelX,
          children: [/*#__PURE__*/jsx(Label, {
            barHeight: barHeight,
            color: selectedTheme.xAxis.labelColor,
            label: label,
            labelWidth: labelWidth,
            y: y
          }), trendIndicatorProps != null && /*#__PURE__*/jsx("g", {
            transform: `translate(${labelWidth + HORIZONTAL_BAR_LABEL_OFFSET}, ${y + trendYOffset})`,
            children: /*#__PURE__*/jsx(TrendIndicator, { ...trendIndicatorProps
            })
          })]
        }), /*#__PURE__*/jsx("rect", {
          className: styles.Bar,
          x: 0,
          y: y - HORIZONTAL_SPACE_BETWEEN_SINGLE / 2,
          width: clampedSize,
          height: barHeight + HORIZONTAL_SPACE_BETWEEN_SINGLE,
          fill: "transparent",
          style: {
            transform: isNegative ? 'scaleX(-1)' : ''
          },
          ...getColorVisionEventAttrs({
            type: COLOR_VISION_SINGLE_ITEM,
            index: seriesIndex
          }),
          tabIndex: -1,
          role: "img",
          "aria-label": ariaLabel
        })]
      }, `series-${seriesIndex}-${id}-${name}`);
    })
  });
}

export { HorizontalBars };
