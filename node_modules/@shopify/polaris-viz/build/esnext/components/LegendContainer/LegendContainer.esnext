import { useRef, useState, useEffect, Fragment } from 'react';
import isEqual from 'fast-deep-equal';
import { useTheme, useChartContext, LEGENDS_BOTTOM_MARGIN, LEGENDS_TOP_MARGIN, getColorVisionStylesForActiveIndex, getColorVisionEventAttrs } from '@shopify/polaris-viz-core';
import { DEFAULT_LEGEND_HEIGHT, DEFAULT_LEGEND_WIDTH } from '../../constants.esnext';
import style from './LegendContainer.scss.esnext';
import { HiddenLegendTooltip } from './components/HiddenLegendTooltip.esnext';
import { useOverflowLegend } from './hooks/useOverflowLegend.esnext';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useResizeObserver } from '../../hooks/useResizeObserver.esnext';
import { useWatchColorVisionEvents } from '../../hooks/ColorVisionA11y/useWatchColorVisionEvents.esnext';
import { classNames } from '../../utilities/classnames.esnext';
import { Legend } from '../Legend/Legend.esnext';

function LegendContainer({
  colorVisionType,
  data: allData,
  onDimensionChange,
  direction = 'horizontal',
  fullWidth = false,
  position = 'bottom',
  maxWidth,
  renderLegendContent,
  enableHideOverflow = false,
  renderHiddenLegendLabel = count => `+${count} more`,
  dimensions
}) {
  var _renderLegendContent;

  const selectedTheme = useTheme();
  const {
    setRef,
    entry
  } = useResizeObserver();
  const {
    theme
  } = useChartContext();
  const previousHeight = useRef(DEFAULT_LEGEND_HEIGHT);
  const previousWidth = useRef(DEFAULT_LEGEND_WIDTH);
  const [activeIndex, setActiveIndex] = useState(-1);
  const isPositionTop = position.includes('top');
  const isPositionLeft = position.includes('left');
  const {
    horizontalMargin
  } = selectedTheme.grid;
  const leftMargin = isPositionLeft ? 0 : horizontalMargin;
  const legendItemDimensions = useRef([{
    width: 0,
    height: 0
  }]);
  const [activatorWidth, setActivatorWidth] = useState(0);
  const overflowLegendProps = direction === 'horizontal' ? {
    direction: 'horizontal',
    data: allData,
    enableHideOverflow,
    legendItemDimensions,
    width: (dimensions === null || dimensions === void 0 ? void 0 : dimensions.width) || 0,
    activatorWidth,
    leftMargin,
    horizontalMargin
  } : {
    direction: 'vertical',
    data: allData,
    height: dimensions === null || dimensions === void 0 ? void 0 : dimensions.height,
    enableHideOverflow,
    legendItemDimensions
  };
  const {
    displayedData,
    hiddenData
  } = useOverflowLegend(overflowLegendProps);
  const hasHiddenData = enableHideOverflow && displayedData.length < allData.length;
  const styleMap = {
    horizontal: {
      justifyContent: 'flex-end',
      margin: isPositionTop ? `0 ${horizontalMargin}px ${LEGENDS_BOTTOM_MARGIN}px ${leftMargin}px` : `${LEGENDS_TOP_MARGIN}px ${horizontalMargin}px 0 ${leftMargin}px`,
      flexDirection: 'row',
      flexWrap: enableHideOverflow ? 'nowrap' : 'wrap'
    },
    vertical: {
      alignItems: 'flex-start',
      margin: `0 ${horizontalMargin}px 0 ${leftMargin}px`,
      flexDirection: 'column',
      maxWidth: fullWidth ? 'none' : maxWidth,
      flex: fullWidth ? 1 : 'initial'
    },
    centerTiles: {
      justifyContent: 'center'
    }
  };

  const shouldCenterTiles = pos => {
    if (pos === 'top' || pos === 'bottom') {
      return {
        justifyContent: 'center'
      };
    }
  };

  const colorVisionInteractionMethods = {
    getColorVisionStyles: index => getColorVisionStylesForActiveIndex({
      activeIndex,
      index
    }),
    getColorVisionEventAttrs: index => getColorVisionEventAttrs({
      type: colorVisionType,
      index
    })
  };
  useWatchColorVisionEvents({
    type: colorVisionType,
    onIndexChange: ({
      detail
    }) => {
      setActiveIndex(detail.index);
    }
  });
  useEffect(() => {
    const newHeight = entry === null || entry === void 0 ? void 0 : entry.contentRect.height;
    const newWidth = entry === null || entry === void 0 ? void 0 : entry.contentRect.width;
    const newDimensions = {
      height: newHeight,
      width: newWidth
    };

    if (entry == null || newHeight == null || newWidth == null) {
      return;
    }

    if (isEqual({
      height: previousHeight.current,
      width: previousWidth.current
    }, newDimensions)) {
      return;
    }

    previousHeight.current = newDimensions.height;
    previousWidth.current = newDimensions.width;
    onDimensionChange(newDimensions);
  }, [entry, onDimensionChange]);
  return /*#__PURE__*/jsx("div", {
    className: classNames(style.Container),
    ref: setRef,
    role: "list",
    style: { ...styleMap[direction],
      ...shouldCenterTiles(position)
    },
    children: (_renderLegendContent = renderLegendContent === null || renderLegendContent === void 0 ? void 0 : renderLegendContent(colorVisionInteractionMethods)) !== null && _renderLegendContent !== void 0 ? _renderLegendContent : /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Legend, {
        activeIndex: activeIndex,
        colorVisionType: colorVisionType,
        data: hasHiddenData ? displayedData : allData,
        theme: theme,
        itemDimensions: enableHideOverflow ? legendItemDimensions : undefined,
        truncate: hasHiddenData
      }), hasHiddenData && /*#__PURE__*/jsx(HiddenLegendTooltip, {
        activeIndex: activeIndex,
        colorVisionType: colorVisionType,
        data: hiddenData,
        theme: theme,
        label: renderHiddenLegendLabel(allData.length - displayedData.length),
        lastVisibleIndex: allData.length - hiddenData.length,
        setActivatorWidth: setActivatorWidth,
        dimensions: dimensions
      })]
    })
  });
}

export { LegendContainer };
