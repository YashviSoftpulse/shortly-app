import { useState, Fragment } from 'react';
import { useChartContext, COLOR_VISION_SINGLE_ITEM, isGradientType, changeColorOpacity, getColorVisionStylesForActiveIndex, LinearGradientWithStops, changeGradientOpacity, DataType } from '@shopify/polaris-viz-core';
import { jsxs, jsx } from 'react/jsx-runtime';
import { useWatchColorVisionEvents } from '../../../../hooks/ColorVisionA11y/useWatchColorVisionEvents.esnext';
import { Point } from '../../../Point/Point.esnext';

function Points({
  activePointIndex,
  animatedCoordinates,
  colors,
  getXPosition,
  stackedValues,
  tooltipId,
  xScale,
  yScale
}) {
  const [activeLineIndex, setActiveLineIndex] = useState(-1);
  const {
    shouldAnimate
  } = useChartContext();
  useWatchColorVisionEvents({
    type: COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => {
      setActiveLineIndex(detail.index);
    }
  });
  return /*#__PURE__*/jsxs(Fragment, {
    children: [stackedValues.map((stack, stackIndex) => {
      if (activePointIndex == null) {
        return null;
      }

      const [_, y] = stack[activePointIndex];
      const id = `${tooltipId}-point-${stackIndex}`;
      const color = colors[stackIndex];
      const animatedYPostion = animatedCoordinates == null || animatedCoordinates[stackIndex] == null ? yScale(y) : animatedCoordinates[stackIndex].to(coord => coord.y);
      const pointColor = isGradientType(color) ? `url(#${id})` : changeColorOpacity(color);
      return /*#__PURE__*/jsxs("g", {
        style: getColorVisionStylesForActiveIndex({
          activeIndex: activeLineIndex,
          index: stackIndex,
          fadedOpacity: 0
        }),
        children: [isGradientType(color) && /*#__PURE__*/jsx("defs", {
          children: /*#__PURE__*/jsx(LinearGradientWithStops, {
            id: id,
            gradient: changeGradientOpacity(color),
            gradientUnits: "userSpaceOnUse",
            y1: "100%",
            y2: "0%"
          })
        }), /*#__PURE__*/jsx(Point, {
          color: pointColor,
          cx: getXPosition({
            isCrosshair: false,
            index: stackIndex
          }),
          cy: animatedYPostion,
          active: true,
          index: stackIndex,
          tabIndex: stackIndex === 0 ? 0 : -1,
          isAnimated: shouldAnimate
        })]
      }, stackIndex);
    }), stackedValues[0].map(([x, y], dataIndex) => {
      // These are the points used for tabbing and
      // a11y. We only render a single series otherwise
      // the tabbing would loop through each set of points
      // for each series.
      return /*#__PURE__*/jsx(Point, {
        dataType: DataType.Point,
        color: "white",
        cx: xScale(dataIndex),
        cy: yScale(y),
        active: true,
        index: dataIndex,
        tabIndex: 0,
        ariaLabelledby: tooltipId,
        isAnimated: false,
        ariaHidden: false,
        visuallyHidden: true
      }, `point-${dataIndex}-${x}}`);
    })]
  });
}

export { Points };
