import { useMemo, useState } from 'react';
import { useTheme, uniqueId, LINE_HEIGHT, ChartMargin, useAriaLabel, HORIZONTAL_SPACE_BETWEEN_CHART_AND_AXIS, DataType, COLOR_VISION_SINGLE_ITEM } from '@shopify/polaris-viz-core';
import { animated } from '@react-spring/web';
import { ChartElements } from '../ChartElements/index.esnext';
import { useFormattedLabels } from '../../hooks/useFormattedLabels.esnext';
import { ANNOTATIONS_LABELS_OFFSET } from '../../constants.esnext';
import { jsxs, jsx } from 'react/jsx-runtime';
import { useColorVisionEvents } from '../../hooks/ColorVisionA11y/useColorVisionEvents.esnext';
import { useHorizontalSeriesColors } from '../../hooks/useHorizontalSeriesColors.esnext';
import { useLegend } from '../LegendContainer/hooks/useLegend.esnext';
import { useDataForHorizontalChart } from '../../hooks/useDataForHorizontalChart.esnext';
import { formatDataIntoGroups } from '../../utilities/formatDataIntoGroups.esnext';
import { useHorizontalStackedValues } from '../../hooks/useHorizontalStackedValues.esnext';
import { useHorizontalXScale } from '../../hooks/useHorizontalXScale.esnext';
import { useHorizontalBarSizes } from '../../hooks/useHorizontalBarSizes.esnext';
import { useBarChartTooltipContent } from '../../hooks/useBarChartTooltipContent.esnext';
import { useHorizontalTransitions } from '../../hooks/useHorizontalTransitions.esnext';
import { checkAvailableAnnotations } from '../Annotations/utilities/checkAvailableAnnotations.esnext';
import { VerticalGridLines } from './components/VerticalGridLines/VerticalGridLines.esnext';
import { HorizontalBarChartXAxisLabels } from '../HorizontalBarChartXAxisLabels/HorizontalBarChartXAxisLabels.esnext';
import { GradientDefs } from '../shared/GradientDefs/GradientDefs.esnext';
import { HorizontalGroup } from '../shared/HorizontalGroup/HorizontalGroup.esnext';
import { HorizontalBarChartXAnnotations } from './components/HorizontalBarChartXAnnotations/HorizontalBarChartXAnnotations.esnext';
import { HorizontalBarChartYAnnotations } from './components/HorizontalBarChartYAnnotations/HorizontalBarChartYAnnotations.esnext';
import { TooltipWrapper } from '../TooltipWrapper/TooltipWrapper.esnext';
import { getAlteredHorizontalBarPosition } from './utilities/getAlteredHorizontalBarPosition.esnext';
import { LegendContainer } from '../LegendContainer/LegendContainer.esnext';
import { eventPointNative } from '../../utilities/eventPoint.esnext';
import { TOOLTIP_POSITION_DEFAULT_RETURN } from '../TooltipWrapper/constants.esnext';

function Chart({
  annotationsLookupTable,
  data,
  dimensions,
  renderHiddenLegendLabel,
  renderLegendContent,
  renderTooltipContent,
  seriesNameFormatter,
  showLegend,
  type,
  xAxisOptions,
  yAxisOptions
}) {
  useColorVisionEvents({
    enabled: data.length > 1
  });
  const selectedTheme = useTheme();
  const id = useMemo(() => uniqueId('HorizontalBarChart'), []);
  const isStacked = type === 'stacked';
  const [svgRef, setSvgRef] = useState(null);
  const [xAxisHeight, setXAxisHeight] = useState(LINE_HEIGHT);
  const [annotationsHeight, setAnnotationsHeight] = useState(0);
  const {
    longestSeriesCount,
    seriesColors
  } = useHorizontalSeriesColors(data);
  const {
    legend,
    setLegendDimensions,
    height,
    width
  } = useLegend({
    data: [{
      shape: 'Bar',
      series: data
    }],
    dimensions,
    showLegend,
    colors: seriesColors,
    seriesNameFormatter
  });
  const {
    allNumbers,
    longestLabel,
    areAllNegative
  } = useDataForHorizontalChart({
    data,
    isSimple: false,
    isStacked,
    labelFormatter: xAxisOptions.labelFormatter
  });
  const highestValueForSeries = useMemo(() => {
    const groups = formatDataIntoGroups(data);
    const maxes = groups.map(numbers => {
      const values = numbers.map(value => value).filter(Boolean);

      if (values.length === 0) {
        return 0;
      }

      return areAllNegative ? Math.min(...values) : Math.max(...values);
    });
    return maxes;
  }, [data, areAllNegative]);
  const {
    stackedValues,
    stackedMin,
    stackedMax
  } = useHorizontalStackedValues({
    isStacked,
    data
  });
  const chartYPosition = ChartMargin.Top + annotationsHeight;
  const drawableHeight = height - xAxisHeight - chartYPosition;
  const {
    xScale,
    ticks,
    ticksFormatted,
    drawableWidth,
    chartXPosition
  } = useHorizontalXScale({
    allNumbers,
    stackedMin,
    stackedMax,
    isStacked,
    maxWidth: width - longestLabel.negative - longestLabel.positive,
    labelFormatter: xAxisOptions.labelFormatter,
    longestLabel
  });
  const {
    barHeight,
    chartHeight,
    groupBarsAreaHeight,
    groupHeight
  } = useHorizontalBarSizes({
    chartDimensions: {
      width: drawableWidth,
      height: drawableHeight
    },
    isSimple: xAxisOptions.hide,
    isStacked,
    seriesLength: longestSeriesCount,
    singleBarCount: data.length,
    xAxisHeight
  });
  const annotationsDrawableHeight = chartYPosition + chartHeight + ANNOTATIONS_LABELS_OFFSET;
  const getTooltipMarkup = useBarChartTooltipContent({
    data,
    seriesColors,
    renderTooltipContent,
    seriesNameFormatter
  });
  const {
    transitions
  } = useHorizontalTransitions({
    series: data,
    groupHeight,
    chartXPosition
  });
  const zeroPosition = longestLabel.negative + xScale(0);
  const labelWidth = drawableWidth / ticks.length;
  const chartBounds = {
    width,
    height,
    x: chartXPosition,
    y: 0
  };
  const {
    hasXAxisAnnotations,
    hasYAxisAnnotations
  } = checkAvailableAnnotations(annotationsLookupTable);
  const {
    unformattedLabels
  } = useFormattedLabels({
    data,
    labelFormatter: yAxisOptions.labelFormatter
  });
  const getAriaLabel = useAriaLabel(data, {
    xAxisLabelFormatter: xAxisOptions.labelFormatter,
    yAxisLabelFormatter: yAxisOptions.labelFormatter
  });
  return /*#__PURE__*/jsxs(ChartElements.Div, {
    height: height,
    width: width,
    children: [/*#__PURE__*/jsxs(ChartElements.Svg, {
      setRef: setSvgRef,
      width: width,
      height: height,
      children: [xAxisOptions.hide === true ? null : /*#__PURE__*/jsxs("g", {
        transform: `translate(${chartXPosition}, ${chartYPosition})`,
        children: [/*#__PURE__*/jsx(VerticalGridLines, {
          chartHeight: chartHeight + HORIZONTAL_SPACE_BETWEEN_CHART_AND_AXIS,
          stroke: selectedTheme.grid.color,
          ticks: ticks,
          xScale: xScale
        }), /*#__PURE__*/jsx(HorizontalBarChartXAxisLabels, {
          allowLineWrap: xAxisOptions.allowLineWrap,
          chartX: -labelWidth / 2,
          chartY: drawableHeight,
          labels: ticksFormatted,
          labelWidth: labelWidth,
          onHeightChange: setXAxisHeight,
          ticks: ticks,
          xScale: xScale
        })]
      }), /*#__PURE__*/jsx(GradientDefs, {
        direction: "horizontal",
        gradientUnits: isStacked ? 'objectBoundingBox' : 'userSpaceOnUse',
        id: id,
        seriesColors: seriesColors,
        size: isStacked ? '100%' : `${width}px`
      }), /*#__PURE__*/jsx("g", {
        transform: `translate(${0}, ${chartYPosition})`,
        children: transitions((style, item, _transition, index) => {
          var _item$key;

          const {
            opacity,
            transform
          } = style;
          const name = (_item$key = item.key) !== null && _item$key !== void 0 ? _item$key : '';
          const ariaLabel = getAriaLabel({
            seriesIndex: item.index,
            key: item.key
          });
          return /*#__PURE__*/jsx(animated.g, {
            style: {
              opacity,
              transform
            },
            children: /*#__PURE__*/jsx(HorizontalGroup, {
              areAllNegative: areAllNegative,
              ariaLabel: ariaLabel,
              barHeight: barHeight,
              containerWidth: width,
              data: data,
              groupHeight: groupHeight,
              id: id,
              index: index,
              isSimple: false,
              isStacked: isStacked,
              name: name,
              stackedValues: stackedValues,
              xAxisOptions: xAxisOptions,
              xScale: xScale,
              yAxisOptions: yAxisOptions,
              zeroPosition: zeroPosition
            })
          }, `group-${name}`);
        })
      }), hasXAxisAnnotations && /*#__PURE__*/jsx("g", {
        transform: `translate(${chartXPosition}, ${0})`,
        children: /*#__PURE__*/jsx(HorizontalBarChartXAnnotations, {
          annotationsLookupTable: annotationsLookupTable,
          drawableHeight: annotationsDrawableHeight,
          drawableWidth: drawableWidth,
          onHeightChange: setAnnotationsHeight,
          xScale: xScale
        })
      }), hasYAxisAnnotations && /*#__PURE__*/jsx("g", {
        transform: `translate(${chartXPosition}, ${chartYPosition})`,
        children: /*#__PURE__*/jsx(HorizontalBarChartYAnnotations, {
          annotationsLookupTable: annotationsLookupTable,
          drawableWidth: drawableWidth,
          groupHeight: groupHeight,
          labels: unformattedLabels,
          zeroPosition: zeroPosition
        })
      })]
    }), highestValueForSeries.length !== 0 && /*#__PURE__*/jsx(TooltipWrapper, {
      bandwidth: groupBarsAreaHeight,
      chartBounds: chartBounds,
      focusElementDataType: DataType.BarGroup,
      getAlteredPosition: getAlteredHorizontalBarPosition,
      getMarkup: getTooltipMarkup,
      getPosition: getTooltipPosition,
      margin: ChartMargin,
      parentRef: svgRef
    }), showLegend && /*#__PURE__*/jsx(LegendContainer, {
      colorVisionType: COLOR_VISION_SINGLE_ITEM,
      data: legend,
      dimensions: dimensions,
      enableHideOverflow: true,
      onDimensionChange: setLegendDimensions,
      renderLegendContent: renderLegendContent,
      renderHiddenLegendLabel: renderHiddenLegendLabel
    })]
  });

  function formatPositionForTooltip(index) {
    if (isStacked) {
      const x = stackedValues[index].reduce((prev, cur) => {
        const [start, end] = cur;

        if (start < 0) {
          return prev;
        }

        return prev + (xScale(end) - xScale(start));
      }, xScale(0));
      return {
        x,
        y: groupHeight * index,
        activeIndex: index
      };
    }

    const highestValue = highestValueForSeries[index];
    const x = chartXPosition + xScale(highestValue);
    return {
      x: highestValue < 0 ? -x : x,
      y: groupHeight * index,
      activeIndex: index
    };
  }

  function getTooltipPosition({
    event,
    index,
    eventType
  }) {
    if (eventType === 'mouse' && event) {
      const point = eventPointNative(event);

      if (point == null) {
        return TOOLTIP_POSITION_DEFAULT_RETURN;
      }

      const {
        svgY
      } = point;
      const currentPoint = svgY - 0;
      const currentIndex = Math.floor(currentPoint / groupHeight);

      if (currentIndex < 0 || currentIndex > longestSeriesCount - 1) {
        return TOOLTIP_POSITION_DEFAULT_RETURN;
      }

      return formatPositionForTooltip(currentIndex);
    } else if (index != null) {
      return formatPositionForTooltip(index);
    }

    return TOOLTIP_POSITION_DEFAULT_RETURN;
  }
}

export { Chart };
