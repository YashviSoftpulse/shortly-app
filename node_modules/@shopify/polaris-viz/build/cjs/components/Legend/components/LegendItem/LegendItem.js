'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var polarisVizCore = require('@shopify/polaris-viz-core');
var React = require('react');
var constants = require('../../constants.js');
var constants$1 = require('../../../../constants.js');
var LegendItem$1 = require('./LegendItem.scss.js');
var jsxRuntime = require('react/jsx-runtime');
var SeriesIcon = require('../../../shared/SeriesIcon/SeriesIcon.js');

const MINIMUM_LEGEND_ITEM_WIDTH = 100;
function LegendItem({
  activeIndex = -1,
  color,
  colorVisionType,
  index,
  isComparison,
  name,
  renderSeriesIcon,
  shape,
  theme,
  value,
  onDimensionChange,
  backgroundColor,
  truncate = false,
  showLegendValues = false,
  seriesNameFormatter = value => `${value}`
}) {
  const selectedTheme = polarisVizCore.useTheme(theme);
  const ref = React.useRef(null);
  const [width, setWidth] = React.useState(0);
  const renderLegendValues = showLegendValues && value != null;
  React.useEffect(() => {
    if (onDimensionChange && ref.current != null) {
      const {
        width,
        height
      } = ref.current.getBoundingClientRect();
      setWidth(width);
      onDimensionChange(index, {
        width: Math.min(MINIMUM_LEGEND_ITEM_WIDTH, Math.round(width)),
        height
      });
    }
  }, [onDimensionChange, ref, index]);
  const colorBlindAttrs = colorVisionType == null ? {} : polarisVizCore.getColorVisionEventAttrs({
    type: colorVisionType,
    index
  });
  const background = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : selectedTheme.legend.backgroundColor;
  return /*#__PURE__*/jsxRuntime.jsxs("button", { ...colorBlindAttrs,
    style: {
      background: background !== null && background !== void 0 ? background : 'none',
      ...polarisVizCore.getColorVisionStylesForActiveIndex({
        activeIndex,
        index
      }),
      paddingLeft: background ? constants.LEGEND_ITEM_LEFT_PADDING : 0,
      paddingRight: background ? constants.LEGEND_ITEM_RIGHT_PADDING : constants.LEGEND_ITEM_LEFT_PADDING,
      gap: constants.LEGEND_ITEM_GAP,
      // if there is overflow, add a max width and truncate with ellipsis
      maxWidth: truncate ? MINIMUM_LEGEND_ITEM_WIDTH : '100%',
      // if the item width is already less than MINIMUM_LEGEND_ITEM_WIDTH, don't set a minWidth
      minWidth: width < MINIMUM_LEGEND_ITEM_WIDTH ? undefined : MINIMUM_LEGEND_ITEM_WIDTH
    },
    className: LegendItem$1["default"].Legend,
    ref: ref,
    title: name,
    children: [renderSeriesIcon == null ? /*#__PURE__*/jsxRuntime.jsx("span", {
      style: {
        height: constants$1.PREVIEW_ICON_SIZE,
        width: constants$1.PREVIEW_ICON_SIZE
      },
      className: LegendItem$1["default"].IconContainer,
      children: /*#__PURE__*/jsxRuntime.jsx(SeriesIcon.SeriesIcon, {
        shape: shape,
        color: color,
        isComparison: isComparison
      })
    }) : renderSeriesIcon(), /*#__PURE__*/jsxRuntime.jsxs("span", {
      className: LegendItem$1["default"].TextContainer,
      children: [/*#__PURE__*/jsxRuntime.jsx("span", {
        className: LegendItem$1["default"].Text,
        style: {
          color: selectedTheme.legend.labelColor
        },
        children: seriesNameFormatter(name)
      }), renderLegendValues ? /*#__PURE__*/jsxRuntime.jsx("span", {
        className: LegendItem$1["default"].Text,
        style: {
          color: selectedTheme.legend.valueColor
        },
        children: value
      }) : null]
    })]
  });
}

exports.LegendItem = LegendItem;
exports.MINIMUM_LEGEND_ITEM_WIDTH = MINIMUM_LEGEND_ITEM_WIDTH;
