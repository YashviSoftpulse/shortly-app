'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var d3Shape = require('d3-shape');
var polarisVizCore = require('@shopify/polaris-viz-core');
var index = require('../ChartElements/index.js');
var constants$1 = require('../../constants.js');
var useStackedChartTooltipContent = require('./hooks/useStackedChartTooltipContent.js');
var yAxisMinMax = require('./utilities/yAxisMinMax.js');
var getAlteredStackedAreaChartPosition = require('./utilities/getAlteredStackedAreaChartPosition.js');
var Chart$1 = require('./Chart.scss.js');
var jsxRuntime = require('react/jsx-runtime');
var types = require('../TooltipWrapper/types.js');
var useColorVisionEvents = require('../../hooks/ColorVisionA11y/useColorVisionEvents.js');
var useLegend = require('../LegendContainer/hooks/useLegend.js');
var useStackedData = require('./hooks/useStackedData.js');
var useLinearLabelsAndDimensions = require('../../hooks/useLinearLabelsAndDimensions.js');
var useLinearChartAnimations = require('../../hooks/useLinearChartAnimations.js');
var checkAvailableAnnotations = require('../Annotations/utilities/checkAvailableAnnotations.js');
var XAxis = require('../XAxis/XAxis.js');
var HorizontalGridLines = require('../HorizontalGridLines/HorizontalGridLines.js');
var YAxis = require('../YAxis/YAxis.js');
var VisuallyHiddenRows = require('../VisuallyHiddenRows/VisuallyHiddenRows.js');
var StackedAreas = require('./components/StackedAreas/StackedAreas.js');
var Crosshair = require('../Crosshair/Crosshair.js');
var Points = require('./components/Points/Points.js');
var Annotations = require('../Annotations/Annotations.js');
var YAxisAnnotations = require('../Annotations/YAxisAnnotations.js');
var TooltipWrapper = require('../TooltipWrapper/TooltipWrapper.js');
var LegendContainer = require('../LegendContainer/LegendContainer.js');
var eventPoint = require('../../utilities/eventPoint.js');
var constants = require('../TooltipWrapper/constants.js');

const TOOLTIP_POSITION = {
  horizontal: types.TooltipHorizontalOffset.Left,
  vertical: types.TooltipVerticalOffset.Center
};
function Chart({
  annotationsLookupTable,
  xAxisOptions,
  data,
  dimensions,
  renderLegendContent,
  renderTooltipContent,
  showLegend,
  theme,
  yAxisOptions,
  renderHiddenLegendLabel,
  seriesNameFormatter
}) {
  var _dimensions$x, _dimensions$y;

  useColorVisionEvents.useColorVisionEvents({
    enabled: data.length > 1
  });
  const selectedTheme = polarisVizCore.useTheme(theme);
  const seriesColors = polarisVizCore.useThemeSeriesColors(data, selectedTheme);
  const [activePointIndex, setActivePointIndex] = React.useState(null);
  const [svgRef, setSvgRef] = React.useState(null);
  const [xAxisHeight, setXAxisHeight] = React.useState(polarisVizCore.LINE_HEIGHT);
  const [annotationsHeight, setAnnotationsHeight] = React.useState(0);
  const {
    legend,
    setLegendDimensions,
    height,
    width
  } = useLegend.useLegend({
    colors: seriesColors,
    data: [{
      shape: 'Line',
      series: data
    }],
    dimensions,
    showLegend,
    seriesNameFormatter
  });
  const tooltipId = polarisVizCore.useUniqueId('stackedAreaChart');
  const hideXAxis = xAxisOptions.hide || selectedTheme.xAxis.hide;
  const {
    stackedValues,
    longestSeriesIndex,
    longestSeriesLength,
    labels: formattedLabels
  } = useStackedData.useStackedData({
    data,
    xAxisOptions
  });
  const zeroLineData = data.map(series => ({ ...series,
    data: series.data.map(point => ({ ...point,
      value: 0
    }))
  }));
  const {
    stackedValues: zeroLineValues
  } = useStackedData.useStackedData({
    data: zeroLineData,
    xAxisOptions
  });
  const {
    minY,
    maxY
  } = yAxisMinMax.yAxisMinMax(stackedValues);
  const yScaleOptions = {
    formatYAxisLabel: yAxisOptions.labelFormatter,
    integersOnly: yAxisOptions.integersOnly,
    maxYOverride: yAxisOptions.maxYOverride,
    max: maxY,
    min: minY
  };
  const {
    yAxisLabelWidth
  } = polarisVizCore.useYScale({ ...yScaleOptions,
    drawableHeight: height,
    verticalOverflow: selectedTheme.grid.verticalOverflow
  });
  const {
    drawableWidth,
    drawableHeight,
    chartXPosition,
    chartYPosition,
    xAxisBounds,
    yAxisBounds
  } = polarisVizCore.useChartPositions({
    annotationsHeight,
    height,
    width,
    xAxisHeight,
    yAxisWidth: yAxisLabelWidth
  });
  const {
    xAxisDetails,
    xScale,
    labels
  } = useLinearLabelsAndDimensions.useLinearLabelsAndDimensions({
    data,
    drawableWidth,
    hideXAxis,
    labels: formattedLabels,
    longestSeriesLength
  });
  const {
    ticks,
    yScale
  } = polarisVizCore.useYScale({ ...yScaleOptions,
    drawableHeight,
    verticalOverflow: selectedTheme.grid.verticalOverflow
  });
  const annotationsDrawableHeight = chartYPosition + drawableHeight + constants$1.ANNOTATIONS_LABELS_OFFSET;
  const getTooltipMarkup = useStackedChartTooltipContent.useStackedChartTooltipContent({
    data,
    renderTooltipContent,
    seriesColors,
    seriesNameFormatter
  });
  const lineGenerator = React.useMemo(() => {
    const generator = d3Shape.line().x((_, index) => xScale == null ? 0 : xScale(index)).y(({
      value
    }) => yScale(value !== null && value !== void 0 ? value : 0)).defined(({
      value
    }) => value != null);

    if (selectedTheme.line.hasSpline) {
      generator.curve(polarisVizCore.curveStepRounded);
    }

    return generator;
  }, [xScale, yScale, selectedTheme.line.hasSpline]);
  const seriesForAnimation = React.useMemo(() => {
    return stackedValues.map(value => {
      return {
        name: '',
        data: value.map(val => {
          return {
            key: '',
            value: val[1]
          };
        })
      };
    });
  }, [stackedValues]);
  const {
    animatedCoordinates
  } = useLinearChartAnimations.useLinearChartAnimations({
    data: seriesForAnimation,
    lineGenerator,
    activeIndex: activePointIndex
  });

  const getXPosition = ({
    isCrosshair,
    index
  }) => {
    if (xScale == null) {
      return 0;
    }

    const offset = isCrosshair ? selectedTheme.crossHair.width / 2 : 0;

    if (index != null && animatedCoordinates != null && animatedCoordinates[index] != null && animatedCoordinates[index]) {
      return animatedCoordinates[index].to(coord => coord.x - offset);
    }

    return xScale(activePointIndex == null ? 0 : activePointIndex) - offset;
  };

  if (xScale == null || drawableWidth == null || yAxisLabelWidth == null) {
    return null;
  }

  const chartBounds = {
    width,
    height,
    x: (_dimensions$x = dimensions === null || dimensions === void 0 ? void 0 : dimensions.x) !== null && _dimensions$x !== void 0 ? _dimensions$x : chartXPosition,
    y: (_dimensions$y = dimensions === null || dimensions === void 0 ? void 0 : dimensions.y) !== null && _dimensions$y !== void 0 ? _dimensions$y : chartYPosition
  };
  const {
    hasXAxisAnnotations,
    hasYAxisAnnotations
  } = checkAvailableAnnotations.checkAvailableAnnotations(annotationsLookupTable);
  const halfXAxisLabelWidth = xAxisDetails.labelWidth / 2;
  return /*#__PURE__*/jsxRuntime.jsxs(index.ChartElements.Div, {
    height: height,
    width: width,
    children: [/*#__PURE__*/jsxRuntime.jsxs(index.ChartElements.Svg, {
      width: width,
      setRef: setSvgRef,
      role: "table",
      height: height,
      children: [hideXAxis ? null : /*#__PURE__*/jsxRuntime.jsx(XAxis.XAxis, {
        allowLineWrap: xAxisOptions.allowLineWrap,
        isLinearChart: true,
        labels: labels,
        labelWidth: xAxisDetails.labelWidth,
        onHeightChange: setXAxisHeight,
        reducedLabelIndexes: xAxisDetails.reducedLabelIndexes,
        x: xAxisBounds.x - halfXAxisLabelWidth,
        xScale: xScale,
        y: xAxisBounds.y
      }), selectedTheme.grid.showHorizontalLines ? /*#__PURE__*/jsxRuntime.jsx(HorizontalGridLines.HorizontalGridLines, {
        ticks: ticks,
        transform: {
          x: selectedTheme.grid.horizontalOverflow ? 0 : chartXPosition,
          y: chartYPosition
        },
        width: selectedTheme.grid.horizontalOverflow ? width : drawableWidth
      }) : null, /*#__PURE__*/jsxRuntime.jsx(YAxis.YAxis, {
        ticks: ticks,
        width: yAxisLabelWidth,
        textAlign: "right",
        x: yAxisBounds.x,
        y: yAxisBounds.y
      }), /*#__PURE__*/jsxRuntime.jsx(VisuallyHiddenRows.VisuallyHiddenRows, {
        data: data,
        formatYAxisLabel: yAxisOptions.labelFormatter,
        xAxisLabels: labels
      }), /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition},${chartYPosition})`,
        className: Chart$1["default"].Group,
        "area-hidden": "true",
        children: /*#__PURE__*/jsxRuntime.jsx(StackedAreas.StackedAreas, {
          stackedValues: stackedValues,
          zeroLineValues: zeroLineValues,
          xScale: xScale,
          yScale: yScale,
          colors: seriesColors,
          theme: theme
        })
      }), activePointIndex == null ? null : /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition},${chartYPosition})`,
        children: /*#__PURE__*/jsxRuntime.jsx(Crosshair.Crosshair, {
          x: getXPosition({
            isCrosshair: true,
            index: 0
          }),
          height: drawableHeight,
          theme: theme
        })
      }), /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition},${chartYPosition})`,
        children: /*#__PURE__*/jsxRuntime.jsx(Points.Points, {
          activePointIndex: activePointIndex,
          animatedCoordinates: animatedCoordinates,
          colors: seriesColors,
          getXPosition: getXPosition,
          stackedValues: stackedValues,
          tooltipId: tooltipId,
          xScale: xScale,
          yScale: yScale
        })
      }), hasXAxisAnnotations && /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition},0)`,
        tabIndex: -1,
        children: /*#__PURE__*/jsxRuntime.jsx(Annotations.Annotations, {
          annotationsLookupTable: annotationsLookupTable,
          axisLabelWidth: xAxisDetails.labelWidth,
          drawableHeight: annotationsDrawableHeight,
          drawableWidth: drawableWidth,
          labels: labels,
          onHeightChange: setAnnotationsHeight,
          xScale: xScale
        })
      }), hasYAxisAnnotations && /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition},${chartYPosition})`,
        tabIndex: -1,
        children: /*#__PURE__*/jsxRuntime.jsx(YAxisAnnotations.YAxisAnnotations, {
          annotationsLookupTable: annotationsLookupTable,
          drawableHeight: annotationsDrawableHeight,
          drawableWidth: drawableWidth,
          ticks: ticks,
          yScale: yScale
        })
      })]
    }), longestSeriesLength !== -1 && /*#__PURE__*/jsxRuntime.jsx(TooltipWrapper.TooltipWrapper, {
      alwaysUpdatePosition: true,
      chartBounds: chartBounds,
      focusElementDataType: polarisVizCore.DataType.Point,
      getMarkup: getTooltipMarkup,
      getPosition: getTooltipPosition,
      getAlteredPosition: getAlteredStackedAreaChartPosition.getAlteredStackedAreaChartPosition,
      id: tooltipId,
      margin: polarisVizCore.ChartMargin,
      onIndexChange: index => setActivePointIndex(index),
      parentRef: svgRef,
      usePortal: true
    }), showLegend && /*#__PURE__*/jsxRuntime.jsx(LegendContainer.LegendContainer, {
      colorVisionType: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
      data: legend,
      onDimensionChange: setLegendDimensions,
      renderLegendContent: renderLegendContent,
      enableHideOverflow: true,
      dimensions: chartBounds,
      renderHiddenLegendLabel: renderHiddenLegendLabel
    })]
  });

  function getTooltipPosition({
    event,
    index,
    eventType
  }) {
    if (eventType === 'mouse' && event) {
      const point = eventPoint.eventPointNative(event);

      if (point == null || xScale == null) {
        return constants.TOOLTIP_POSITION_DEFAULT_RETURN;
      }

      const {
        svgX
      } = point;
      const closestIndex = Math.round(xScale.invert(svgX - chartXPosition));
      const activeIndex = polarisVizCore.clamp({
        amount: closestIndex,
        min: 0,
        max: data[longestSeriesIndex].data.length - 1
      });
      return {
        x: event.pageX,
        y: event.pageY,
        position: TOOLTIP_POSITION,
        activeIndex
      };
    } else if (index != null) {
      var _xScale, _dimensions$x2, _dimensions$y2;

      const activeIndex = index !== null && index !== void 0 ? index : 0;
      const x = (_xScale = xScale === null || xScale === void 0 ? void 0 : xScale(activeIndex)) !== null && _xScale !== void 0 ? _xScale : 0;
      return {
        x: x + ((_dimensions$x2 = dimensions === null || dimensions === void 0 ? void 0 : dimensions.x) !== null && _dimensions$x2 !== void 0 ? _dimensions$x2 : 0),
        y: (_dimensions$y2 = dimensions === null || dimensions === void 0 ? void 0 : dimensions.y) !== null && _dimensions$y2 !== void 0 ? _dimensions$y2 : 0,
        position: TOOLTIP_POSITION,
        activeIndex: index
      };
    }

    return constants.TOOLTIP_POSITION_DEFAULT_RETURN;
  }
}

exports.Chart = Chart;
