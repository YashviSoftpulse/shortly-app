'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var polarisVizCore = require('@shopify/polaris-viz-core');
var jsxRuntime = require('react/jsx-runtime');
var useWatchColorVisionEvents = require('../../../../hooks/ColorVisionA11y/useWatchColorVisionEvents.js');
var Point = require('../../../Point/Point.js');

function Points({
  activePointIndex,
  animatedCoordinates,
  colors,
  getXPosition,
  stackedValues,
  tooltipId,
  xScale,
  yScale
}) {
  const [activeLineIndex, setActiveLineIndex] = React.useState(-1);
  const {
    shouldAnimate
  } = polarisVizCore.useChartContext();
  useWatchColorVisionEvents.useWatchColorVisionEvents({
    type: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => {
      setActiveLineIndex(detail.index);
    }
  });
  return /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
    children: [stackedValues.map((stack, stackIndex) => {
      if (activePointIndex == null) {
        return null;
      }

      const [_, y] = stack[activePointIndex];
      const id = `${tooltipId}-point-${stackIndex}`;
      const color = colors[stackIndex];
      const animatedYPostion = animatedCoordinates == null || animatedCoordinates[stackIndex] == null ? yScale(y) : animatedCoordinates[stackIndex].to(coord => coord.y);
      const pointColor = polarisVizCore.isGradientType(color) ? `url(#${id})` : polarisVizCore.changeColorOpacity(color);
      return /*#__PURE__*/jsxRuntime.jsxs("g", {
        style: polarisVizCore.getColorVisionStylesForActiveIndex({
          activeIndex: activeLineIndex,
          index: stackIndex,
          fadedOpacity: 0
        }),
        children: [polarisVizCore.isGradientType(color) && /*#__PURE__*/jsxRuntime.jsx("defs", {
          children: /*#__PURE__*/jsxRuntime.jsx(polarisVizCore.LinearGradientWithStops, {
            id: id,
            gradient: polarisVizCore.changeGradientOpacity(color),
            gradientUnits: "userSpaceOnUse",
            y1: "100%",
            y2: "0%"
          })
        }), /*#__PURE__*/jsxRuntime.jsx(Point.Point, {
          color: pointColor,
          cx: getXPosition({
            isCrosshair: false,
            index: stackIndex
          }),
          cy: animatedYPostion,
          active: true,
          index: stackIndex,
          tabIndex: stackIndex === 0 ? 0 : -1,
          isAnimated: shouldAnimate
        })]
      }, stackIndex);
    }), stackedValues[0].map(([x, y], dataIndex) => {
      // These are the points used for tabbing and
      // a11y. We only render a single series otherwise
      // the tabbing would loop through each set of points
      // for each series.
      return /*#__PURE__*/jsxRuntime.jsx(Point.Point, {
        dataType: polarisVizCore.DataType.Point,
        color: "white",
        cx: xScale(dataIndex),
        cy: yScale(y),
        active: true,
        index: dataIndex,
        tabIndex: 0,
        ariaLabelledby: tooltipId,
        isAnimated: false,
        ariaHidden: false,
        visuallyHidden: true
      }, `point-${dataIndex}-${x}}`);
    })]
  });
}

exports.Points = Points;
