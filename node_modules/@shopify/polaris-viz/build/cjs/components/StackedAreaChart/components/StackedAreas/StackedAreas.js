'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var d3Shape = require('d3-shape');
var polarisVizCore = require('@shopify/polaris-viz-core');
var jsxRuntime = require('react/jsx-runtime');
var useWatchColorVisionEvents = require('../../../../hooks/ColorVisionA11y/useWatchColorVisionEvents.js');
var AnimatedArea = require('../Area/AnimatedArea.js');
var Area = require('../Area/Area.js');

function StackedAreas({
  stackedValues,
  xScale,
  yScale,
  colors,
  theme,
  zeroLineValues
}) {
  const [activeLineIndex, setActiveLineIndex] = React.useState(-1);
  const previousStackedValues = polarisVizCore.usePrevious(stackedValues);
  useWatchColorVisionEvents.useWatchColorVisionEvents({
    type: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => {
      setActiveLineIndex(detail.index);
    }
  });
  const selectedTheme = polarisVizCore.useTheme(theme);
  const id = React.useMemo(() => polarisVizCore.uniqueId('stackedAreas'), []);
  const areaGenerator = d3Shape.area().defined(([firstPoint, lastPoint]) => !isNaN(firstPoint) && !isNaN(lastPoint)).x((_, index) => xScale(index)).y0(([firstPoint]) => yScale(firstPoint)).y1(([, lastPoint]) => yScale(lastPoint));
  const lineGenerator = d3Shape.line().defined(([firstPoint, lastPoint]) => !isNaN(firstPoint) && !isNaN(lastPoint)).x((_, index) => xScale(index)).y(([, lastPoint]) => yScale(lastPoint));

  if (selectedTheme.line.hasSpline) {
    areaGenerator.curve(polarisVizCore.curveStepRounded);
    lineGenerator.curve(polarisVizCore.curveStepRounded);
  }

  const duration = React.useMemo(() => {
    const count = stackedValues.length;
    const duration = count > polarisVizCore.LINE_ANIMATION_FAST_COUNT ? polarisVizCore.LINE_ANIMATION_FAST_DURATION : polarisVizCore.LINE_ANIMATION_SLOW_DURATION - count * polarisVizCore.LINE_ANIMATION_DURATION_STEP;
    return Math.round(duration / polarisVizCore.LINE_ANIMATION_DURATION_STEP) * polarisVizCore.LINE_ANIMATION_DURATION_STEP;
  }, [stackedValues.length]);
  return /*#__PURE__*/jsxRuntime.jsx(React.Fragment, {
    children: stackedValues.map((data, index) => {
      const dataIsValidForAnimation = !previousStackedValues || data.length === previousStackedValues[index].length;
      const AreaComponent = dataIsValidForAnimation ? AnimatedArea.AnimatedArea : Area.Area;
      return /*#__PURE__*/jsxRuntime.jsx(AreaComponent, {
        activeLineIndex: activeLineIndex,
        animationIndex: index,
        areaGenerator: areaGenerator,
        colors: colors,
        data: data,
        zeroLineValues: zeroLineValues[index],
        duration: duration,
        id: id,
        index: index,
        lineGenerator: lineGenerator,
        selectedTheme: selectedTheme
      }, `${id}-${index}`);
    })
  });
}

exports.StackedAreas = StackedAreas;
