'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var polarisVizCore = require('@shopify/polaris-viz-core');
var constants = require('../../../constants.js');
var jsxRuntime = require('react/jsx-runtime');
var useWatchColorVisionEvents = require('../../../hooks/ColorVisionA11y/useWatchColorVisionEvents.js');
var useStackedGaps = require('./hooks/useStackedGaps.js');
var getXPosition = require('./utilities/getXPosition.js');
var ZeroValueLine = require('../ZeroValueLine/ZeroValueLine.js');
var StackedBar = require('./components/StackedBar/StackedBar.js');
var GradientDefs = require('../GradientDefs/GradientDefs.js');
var LabelWrapper = require('../LabelWrapper/LabelWrapper.js');
var Label = require('../Label/Label.js');
var getBarId = require('../../../utilities/getBarId.js');

function getBorderRadius({
  lastIndexes,
  seriesIndex
}) {
  const [positive, negative] = lastIndexes;

  if (positive === seriesIndex) {
    return polarisVizCore.BORDER_RADIUS.Right;
  }

  if (negative === seriesIndex) {
    return polarisVizCore.BORDER_RADIUS.Left;
  }

  return polarisVizCore.BORDER_RADIUS.None;
}

function HorizontalStackedBars({
  activeGroupIndex,
  animationDelay,
  barHeight,
  dataKeys,
  groupIndex,
  id,
  name,
  stackedValues,
  xScale,
  areAllNegative,
  isSimple,
  labelFormatter
}) {
  const selectedTheme = polarisVizCore.useTheme();
  const {
    theme,
    characterWidths
  } = polarisVizCore.useChartContext();
  const [activeBarIndex, setActiveBarIndex] = React.useState(-1);
  const hideGroupLabel = selectedTheme.groupLabel.hide;
  useWatchColorVisionEvents.useWatchColorVisionEvents({
    type: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => {
      if (activeGroupIndex === -1 || activeGroupIndex === groupIndex) {
        setActiveBarIndex(detail.index);
      }
    }
  });
  const lastIndexes = React.useMemo(() => {
    let lastPos = -1;
    let lastNeg = -1;
    stackedValues[groupIndex].forEach(([start, end], index) => {
      if (start < 0) {
        lastNeg = index;
      }

      if (end > 0) {
        lastPos = index;
      }
    });
    return [lastPos, lastNeg];
  }, [groupIndex, stackedValues]);
  const gaps = useStackedGaps.useStackedGaps({
    stackedValues,
    groupIndex
  });
  const groupSum = stackedValues[groupIndex].reduce((_, item) => {
    if (item.data) {
      return Object.values(item.data).reduce((sum, value) => sum + value, 0);
    }

    return 0;
  }, 0);
  const isNegative = groupSum && groupSum < 0;
  const label = labelFormatter(groupSum);
  const labelWidth = polarisVizCore.estimateStringWidth(`${label}`, characterWidths);
  const minGroupStartPoint = stackedValues[groupIndex].reduce((min, item) => {
    const start = item[0];
    return start < min ? start : min;
  }, Infinity);
  const maxGroupEndPoint = stackedValues[groupIndex].reduce((max, item) => {
    const end = item[1];
    return end > max ? end : max;
  }, -Infinity);
  const groupLabelX = isNegative ? xScale(minGroupStartPoint) - labelWidth - polarisVizCore.HORIZONTAL_BAR_LABEL_OFFSET : xScale(maxGroupEndPoint) + polarisVizCore.HORIZONTAL_BAR_LABEL_OFFSET;
  return /*#__PURE__*/jsxRuntime.jsxs("g", {
    style: {
      transform: `translate(0, ${polarisVizCore.HORIZONTAL_GROUP_LABEL_HEIGHT}px`
    },
    "aria-hidden": "true",
    children: [stackedValues[groupIndex].map((item, seriesIndex) => {
      var _dataKeys$seriesIndex;

      const [start, end] = item;
      const barId = getBarId.getBarId(id, groupIndex, seriesIndex);
      const width = Math.abs(xScale(end) - xScale(start));
      const borderRadius = getBorderRadius({
        lastIndexes,
        seriesIndex
      });
      const x = getXPosition.getXPosition({
        start,
        end,
        seriesIndex,
        gaps,
        xScale
      });
      const key = (_dataKeys$seriesIndex = dataKeys[seriesIndex]) !== null && _dataKeys$seriesIndex !== void 0 ? _dataKeys$seriesIndex : '';
      const ariaLabel = `${key} ${end}`;
      const areAllValuesZero = stackedValues[groupIndex].every(([start, end]) => start + end === 0);
      return /*#__PURE__*/jsxRuntime.jsx(React.Fragment, {
        children: areAllValuesZero ? /*#__PURE__*/jsxRuntime.jsx(ZeroValueLine.ZeroValueLine, {
          x: areAllNegative ? x - constants.NEGATIVE_ZERO_LINE_OFFSET : x,
          y: barHeight / 2,
          direction: "horizontal"
        }) : /*#__PURE__*/jsxRuntime.jsx(StackedBar.StackedBar, {
          animationDelay: animationDelay,
          activeBarIndex: activeBarIndex,
          ariaLabel: ariaLabel,
          borderRadius: borderRadius,
          color: GradientDefs.getGradientDefId(theme, seriesIndex, id),
          height: barHeight,
          seriesIndex: seriesIndex,
          setActiveBarIndex: setActiveBarIndex,
          width: width,
          x: x,
          zeroPosition: xScale(0)
        }, `${name}${barId}`)
      }, `stackedBar ${barId}`);
    }), !isSimple && !hideGroupLabel && /*#__PURE__*/jsxRuntime.jsx(LabelWrapper.LabelWrapper, {
      animationDelay: animationDelay,
      x: groupLabelX,
      children: /*#__PURE__*/jsxRuntime.jsx(Label.Label, {
        barHeight: barHeight,
        color: selectedTheme.xAxis.labelColor,
        label: label,
        labelWidth: labelWidth,
        y: 0
      })
    })]
  });
}

exports.HorizontalStackedBars = HorizontalStackedBars;
