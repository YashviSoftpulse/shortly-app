'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var polarisVizCore = require('@shopify/polaris-viz-core');
var getZeroIndex = require('../utilities/getZeroIndex.js');
var getTicksBetweenZeroAndMax = require('../utilities/getTicksBetweenZeroAndMax.js');
var getSourceTicksIndex = require('../utilities/getSourceTicksIndex.js');
var getInitialYScaleValues = require('../utilities/getInitialYScaleValues.js');
var useGetDualAxis = require('./useGetDualAxis.js');
var useMixedDataValues = require('./useMixedDataValues.js');

function useDualAxisTicks({
  data,
  drawableHeight
}) {
  const axes = useGetDualAxis.useGetDualAxis({
    data
  });
  const {
    areAllValuesNegative,
    doesOneChartContainAllNegativeValues,
    doBothChartsContainMixedValues,
    shouldPlaceZeroInMiddleOfChart
  } = useMixedDataValues.useMixedDataValues(axes);
  const sourceOfTruthIndex = getSourceTicksIndex.getSourceTicksIndex({
    axes,
    doBothChartsContainMixedValues,
    shouldPlaceZeroInMiddleOfChart
  });
  const primaryAxis = axes[sourceOfTruthIndex === 0 ? 0 : 1];
  const secondaryAxis = axes[sourceOfTruthIndex === 0 ? 1 : 0];
  const initialYScaleValues = getInitialYScaleValues.getInitialYScaleValues({
    drawableHeight,
    primaryAxis,
    shouldPlaceZeroInMiddleOfChart
  });
  const {
    ticks,
    yScale
  } = polarisVizCore.useYScale({ ...initialYScaleValues,
    formatYAxisLabel: primaryAxis.yAxisOptions.labelFormatter,
    integersOnly: primaryAxis.yAxisOptions.integersOnly
  });
  const ticksLength = ticks.length - 1;
  const zeroIndex = getZeroIndex.getZeroIndex({
    doesOneChartContainAllNegativeValues,
    shouldPlaceZeroInMiddleOfChart,
    ticks
  });
  const ticksBetweenZeroAndMax = getTicksBetweenZeroAndMax.getTicksBetweenZeroAndMax({
    doesOneChartContainAllNegativeValues,
    shouldPlaceZeroInMiddleOfChart,
    ticksLength,
    zeroIndex
  });
  let secondaryMaxforTicks = Math.abs(doesOneChartContainAllNegativeValues ? secondaryAxis.min : secondaryAxis.max); // Make the ticks a nice round number between
  // 0 and max.

  secondaryMaxforTicks = polarisVizCore.getClosestDivisibleNumber(secondaryMaxforTicks, ticksBetweenZeroAndMax);
  const tickHeight = Math.abs(secondaryMaxforTicks / ticksBetweenZeroAndMax);
  const intialSecondaryTicks = ticks.map((tick, index) => {
    const alteredIndex = index - zeroIndex;
    const formattedValue = polarisVizCore.roundToDecimals(tickHeight * alteredIndex, 2);
    return {
      value: tickHeight * alteredIndex,
      formattedValue: secondaryAxis.yAxisOptions.labelFormatter(`${formattedValue}`),
      yOffset: yScale(tick.value)
    };
  });
  const primaryTicks = sourceOfTruthIndex === 0 ? ticks : intialSecondaryTicks;
  const secondaryTicks = sourceOfTruthIndex === 0 ? intialSecondaryTicks : ticks;
  return {
    areAllValuesNegative,
    doesOneChartContainAllNegativeValues,
    doBothChartsContainMixedValues,
    primaryTicks,
    primaryAxis,
    secondaryTicks,
    secondaryAxis,
    yScale,
    shouldPlaceZeroInMiddleOfChart,
    ticksBetweenZeroAndMax
  };
}

exports.useDualAxisTicks = useDualAxisTicks;
