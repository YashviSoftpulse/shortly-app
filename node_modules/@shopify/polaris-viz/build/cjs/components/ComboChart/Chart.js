'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var polarisVizCore = require('@shopify/polaris-viz-core');
var index = require('../ChartElements/index.js');
var sortBarChartData = require('../../utilities/sortBarChartData.js');
var getVerticalBarChartTooltipPosition = require('../../utilities/getVerticalBarChartTooltipPosition.js');
var useThemeSeriesColorsForDataGroup = require('../../hooks/useThemeSeriesColorsForDataGroup.js');
var constants = require('../../constants.js');
var useDualAxisTicks = require('./hooks/useDualAxisTicks.js');
var useDualAxisTickWidths = require('./hooks/useDualAxisTickWidths.js');
var useDualAxisScale = require('./hooks/useDualAxisScale.js');
var useXScale = require('./hooks/useXScale.js');
var useSplitDataForCharts = require('./hooks/useSplitDataForCharts.js');
var useComboChartTooltipContent = require('./hooks/useComboChartTooltipContent.js');
var useComboChartPositions = require('./hooks/useComboChartPositions.js');
var jsxRuntime = require('react/jsx-runtime');
var useColorVisionEvents = require('../../hooks/ColorVisionA11y/useColorVisionEvents.js');
var useLegend = require('../LegendContainer/hooks/useLegend.js');
var useReducedLabelIndexes = require('../../hooks/useReducedLabelIndexes.js');
var checkAvailableAnnotations = require('../Annotations/utilities/checkAvailableAnnotations.js');
var HorizontalGridLines = require('../HorizontalGridLines/HorizontalGridLines.js');
var XAxis = require('../XAxis/XAxis.js');
var AxisLabel = require('./components/AxisLabel/AxisLabel.js');
var YAxis = require('../YAxis/YAxis.js');
var ComboBarChart = require('./components/ComboBarChart/ComboBarChart.js');
var ComboLineChart = require('./components/ComboLineChart/ComboLineChart.js');
var Annotations = require('../Annotations/Annotations.js');
var YAxisAnnotations = require('../Annotations/YAxisAnnotations.js');
var TooltipWrapper = require('../TooltipWrapper/TooltipWrapper.js');
var LegendContainer = require('../LegendContainer/LegendContainer.js');
var constants$1 = require('../TooltipWrapper/constants.js');
var types = require('../TooltipWrapper/types.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function Chart({
  annotationsLookupTable,
  data,
  dimensions,
  renderTooltipContent,
  showLegend,
  theme,
  xAxisOptions,
  renderLegendContent,
  seriesNameFormatter
}) {
  const selectedTheme = polarisVizCore.useTheme(theme);
  useColorVisionEvents.useColorVisionEvents();
  const colors = useThemeSeriesColorsForDataGroup.useThemeSeriesColorsForDataGroup(data, selectedTheme);
  const [xAxisHeight, setXAxisHeight] = React.useState(polarisVizCore.LINE_HEIGHT);
  const [svgRef, setSvgRef] = React.useState(null);
  const [activeIndex, setActiveIndex] = React.useState(null);
  const [annotationsHeight, setAnnotationsHeight] = React.useState(0);
  const {
    legend,
    setLegendDimensions,
    height,
    width
  } = useLegend.useLegend({
    colors,
    data,
    dimensions,
    showLegend,
    seriesNameFormatter
  });
  const {
    drawableHeight,
    chartYPosition,
    xAxisBounds,
    yAxisBounds
  } = polarisVizCore.useChartPositions({
    annotationsHeight,
    height,
    width,
    xAxisHeight,
    yAxisWidth: 0
  });
  const annotationsDrawableHeight = chartYPosition + drawableHeight + constants.ANNOTATIONS_LABELS_OFFSET;
  const {
    doBothChartsContainMixedValues,
    doesOneChartContainAllNegativeValues,
    primaryTicks,
    primaryAxis,
    secondaryTicks,
    secondaryAxis,
    shouldPlaceZeroInMiddleOfChart,
    ticksBetweenZeroAndMax,
    yScale
  } = useDualAxisTicks.useDualAxisTicks({
    data,
    drawableHeight
  });
  const {
    leftTickWidth,
    rightTickWidth
  } = useDualAxisTickWidths.useDualAxisTicksWidth(primaryTicks, secondaryTicks);
  const {
    barYScale,
    lineYScale,
    primaryYScale,
    secondaryYScale
  } = useDualAxisScale.useDualAxisScale({
    doesOneChartContainAllNegativeValues,
    doBothChartsContainMixedValues,
    drawableHeight: annotationsDrawableHeight,
    primaryAxis,
    secondaryAxis,
    yScale,
    shouldPlaceZeroInMiddleOfChart,
    ticksBetweenZeroAndMax
  });
  const {
    chartXPosition,
    drawableWidth,
    leftAxis,
    rightAxis
  } = useComboChartPositions.useComboChartPositions({
    leftTickWidth,
    primaryAxis,
    rightTickWidth,
    secondaryAxis,
    width
  });
  const {
    barChartData,
    barChartColors,
    lineChartColors,
    lineChartData,
    barChartIndexOffset,
    lineChartIndexOffset
  } = useSplitDataForCharts.useSplitDataForCharts(data, colors);
  const {
    xScale,
    labels
  } = useXScale.useXScale({
    drawableWidth,
    data,
    xAxisOptions
  });
  const reducedLabelIndexes = useReducedLabelIndexes.useReducedLabelIndexes({
    dataLength: labels.length
  });
  const labelWidth = drawableWidth / labels.length;
  const chartBounds = {
    width,
    height,
    x: chartXPosition,
    y: chartYPosition
  };
  const getTooltipMarkup = useComboChartTooltipContent.useComboChartTooltipContent({
    renderTooltipContent,
    data,
    seriesColors: colors,
    seriesNameFormatter
  });
  const {
    hasXAxisAnnotations,
    hasYAxisAnnotations
  } = checkAvailableAnnotations.checkAvailableAnnotations(annotationsLookupTable);
  return /*#__PURE__*/jsxRuntime.jsxs(index.ChartElements.Div, {
    height: height,
    width: width,
    children: [/*#__PURE__*/jsxRuntime.jsxs(index.ChartElements.Svg, {
      width: width,
      setRef: setSvgRef,
      height: height,
      children: [selectedTheme.grid.showHorizontalLines ? /*#__PURE__*/jsxRuntime.jsx(HorizontalGridLines.HorizontalGridLines, {
        ticks: primaryTicks,
        transform: {
          x: selectedTheme.grid.horizontalOverflow ? 0 : chartXPosition,
          y: chartYPosition
        },
        width: selectedTheme.grid.horizontalOverflow ? width : drawableWidth
      }) : null, /*#__PURE__*/jsxRuntime.jsx(XAxis.XAxis, {
        allowLineWrap: xAxisOptions.allowLineWrap,
        labels: labels,
        labelWidth: labelWidth,
        onHeightChange: setXAxisHeight,
        reducedLabelIndexes: reducedLabelIndexes,
        x: chartXPosition,
        xScale: xScale,
        y: xAxisBounds.y
      }), primaryAxis.name != null && /*#__PURE__*/jsxRuntime.jsx(AxisLabel.AxisLabel, {
        axis: "primary",
        height: drawableHeight,
        name: primaryAxis.name,
        x: leftAxis.labelX,
        y: yAxisBounds.y
      }), /*#__PURE__*/jsxRuntime.jsx(YAxis.YAxis, {
        ticks: primaryTicks,
        textAlign: "right",
        width: leftTickWidth,
        x: leftAxis.x,
        y: yAxisBounds.y
      }), /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition},${chartYPosition})`,
        children: /*#__PURE__*/jsxRuntime.jsx(ComboBarChart.ComboBarChart, {
          indexOffset: barChartIndexOffset,
          colors: barChartColors,
          data: barChartData,
          drawableHeight: drawableHeight,
          drawableWidth: drawableWidth,
          labels: labels,
          yScale: barYScale
        })
      }), /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition + drawableWidth / labels.length / 2},${chartYPosition})`,
        children: /*#__PURE__*/jsxRuntime.jsx(ComboLineChart.ComboLineChart, {
          activeIndex: activeIndex,
          colors: lineChartColors,
          data: lineChartData,
          drawableHeight: drawableHeight,
          drawableWidth: drawableWidth,
          indexOffset: lineChartIndexOffset,
          theme: theme,
          xScale: xScale,
          yScale: lineYScale
        })
      }), hasXAxisAnnotations && /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition},0)`,
        tabIndex: -1,
        children: /*#__PURE__*/jsxRuntime.jsx(Annotations.Annotations, {
          annotationsLookupTable: annotationsLookupTable,
          axisLabelWidth: labelWidth,
          drawableHeight: annotationsDrawableHeight,
          drawableWidth: drawableWidth,
          labels: labels,
          onHeightChange: setAnnotationsHeight,
          xScale: xScale
        })
      }), hasYAxisAnnotations && /*#__PURE__*/jsxRuntime.jsx(React__namespace.Fragment, {
        children: /*#__PURE__*/jsxRuntime.jsxs("g", {
          transform: `translate(${chartXPosition},${chartYPosition})`,
          tabIndex: -1,
          children: [/*#__PURE__*/jsxRuntime.jsx(YAxisAnnotations.YAxisAnnotations, {
            axis: "y1",
            annotationsLookupTable: annotationsLookupTable,
            drawableHeight: annotationsDrawableHeight,
            drawableWidth: drawableWidth,
            ticks: primaryTicks,
            yScale: primaryYScale
          }), /*#__PURE__*/jsxRuntime.jsx(YAxisAnnotations.YAxisAnnotations, {
            axis: "y2",
            annotationsLookupTable: annotationsLookupTable,
            drawableHeight: annotationsDrawableHeight,
            drawableWidth: drawableWidth,
            ticks: secondaryTicks,
            yScale: secondaryYScale
          })]
        })
      }), /*#__PURE__*/jsxRuntime.jsx(YAxis.YAxis, {
        ticks: secondaryTicks,
        textAlign: "left",
        width: rightTickWidth,
        x: rightAxis.x,
        y: yAxisBounds.y
      }), secondaryAxis.name != null && /*#__PURE__*/jsxRuntime.jsx(AxisLabel.AxisLabel, {
        axis: "secondary",
        height: drawableHeight,
        name: secondaryAxis.name,
        x: rightAxis.labelX,
        y: yAxisBounds.y
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(TooltipWrapper.TooltipWrapper, {
      bandwidth: labelWidth,
      chartBounds: chartBounds,
      focusElementDataType: polarisVizCore.DataType.BarGroup,
      getMarkup: getTooltipMarkup,
      getPosition: getTooltipPosition,
      margin: polarisVizCore.ChartMargin,
      onIndexChange: index => setActiveIndex(index),
      parentRef: svgRef
    }), showLegend && /*#__PURE__*/jsxRuntime.jsx(LegendContainer.LegendContainer, {
      colorVisionType: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
      data: legend,
      onDimensionChange: setLegendDimensions,
      renderLegendContent: renderLegendContent
    })]
  });

  function formatPositionForTooltip(index) {
    var _xScale;

    if (index == null) {
      return constants$1.TOOLTIP_POSITION_DEFAULT_RETURN;
    }

    const sortedData = sortBarChartData.sortBarChartData(labels, barChartData.series);
    const xPosition = (_xScale = xScale(index)) !== null && _xScale !== void 0 ? _xScale : 0;
    const sortedDataPos = sortedData[index].map(num => Math.abs(num !== null && num !== void 0 ? num : 0));
    const highestValuePos = Math.max(...sortedDataPos);
    const x = xPosition + chartXPosition;
    const y = barYScale(highestValuePos) + polarisVizCore.ChartMargin.Top;
    return {
      x,
      y: Math.abs(y),
      position: {
        horizontal: types.TooltipHorizontalOffset.Left,
        vertical: types.TooltipVerticalOffset.Above
      },
      activeIndex: index
    };
  }

  function getTooltipPosition({
    event,
    index,
    eventType
  }) {
    return getVerticalBarChartTooltipPosition.getVerticalBarChartTooltipPosition({
      tooltipPosition: {
        event,
        index,
        eventType
      },
      chartXPosition,
      formatPositionForTooltip,
      maxIndex: labels.length - 1,
      step: labelWidth,
      yMin: polarisVizCore.ChartMargin.Top,
      yMax: drawableHeight + Number(polarisVizCore.ChartMargin.Bottom) + xAxisHeight
    });
  }
}

exports.Chart = Chart;
