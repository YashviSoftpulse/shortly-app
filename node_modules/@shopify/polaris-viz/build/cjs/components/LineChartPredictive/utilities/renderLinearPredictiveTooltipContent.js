'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var constants = require('../../../constants.js');
var Styles = require('./Styles.scss.js');
var jsxRuntime = require('react/jsx-runtime');
var TooltipContentContainer = require('../../TooltipContent/components/TooltipContentContainer/TooltipContentContainer.js');
var TooltipTitle = require('../../TooltipContent/components/TooltipTitle/TooltipTitle.js');
var TooltipRow = require('../../TooltipContent/components/TooltipRow/TooltipRow.js');
var LinePreview = require('../../LinePreview/LinePreview.js');
var SeriesIcon = require('../components/SeriesIcon/SeriesIcon.js');

function renderLinearPredictiveTooltipContent(tooltipData) {
  const {
    theme
  } = tooltipData;
  const formatters = {
    keyFormatter: key => `${key}`,
    valueFormatter: value => `${value}`,
    titleFormatter: title => `${title}`,
    ...tooltipData.formatters
  };

  function renderSeriesIcon(color, isComparison) {
    return /*#__PURE__*/jsxRuntime.jsx("div", {
      className: Styles["default"].Icon,
      style: {
        height: constants.PREVIEW_ICON_SIZE,
        width: constants.PREVIEW_ICON_SIZE
      },
      children: isComparison ? /*#__PURE__*/jsxRuntime.jsx(LinePreview.LinePreview, {
        color: color,
        lineStyle: "dotted"
      }) : /*#__PURE__*/jsxRuntime.jsx(SeriesIcon.SeriesIcon, {
        color: color
      })
    });
  }

  function renderContent({
    activeColorVisionIndex
  }) {
    const item = tooltipData.data[0];
    return item.data.map(({
      color,
      key,
      value,
      isComparison
    }, seriesIndex) => {
      var _metadata$relatedInde;

      const metadata = tooltipData.dataSeries[seriesIndex].metadata;
      const activeKey = tooltipData.dataSeries[seriesIndex].data[tooltipData.activeIndex].key;
      const index = (_metadata$relatedInde = metadata === null || metadata === void 0 ? void 0 : metadata.relatedIndex) !== null && _metadata$relatedInde !== void 0 ? _metadata$relatedInde : seriesIndex;
      const isNull = value == null;
      const isPredictiveStartKey = (metadata === null || metadata === void 0 ? void 0 : metadata.startKey) === activeKey;
      const isHidden = isNull || isPredictiveStartKey;
      return /*#__PURE__*/jsxRuntime.jsx(TooltipRow.TooltipRow, {
        activeIndex: activeColorVisionIndex,
        color: color,
        index: index,
        isHidden: isHidden,
        label: formatters.keyFormatter(key),
        renderSeriesIcon: () => renderSeriesIcon(color, isComparison),
        shape: "Line",
        value: formatters.valueFormatter(value !== null && value !== void 0 ? value : 0)
      }, `row-${seriesIndex}`);
    });
  }

  return /*#__PURE__*/jsxRuntime.jsx(TooltipContentContainer.TooltipContentContainer, {
    maxWidth: 300,
    theme: theme,
    children: ({
      activeColorVisionIndex
    }) => /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
      children: [tooltipData.title != null && /*#__PURE__*/jsxRuntime.jsx(TooltipTitle.TooltipTitle, {
        theme: theme,
        children: formatters.titleFormatter(tooltipData.title)
      }), renderContent({
        activeColorVisionIndex
      })]
    })
  });
}

exports.renderLinearPredictiveTooltipContent = renderLinearPredictiveTooltipContent;
