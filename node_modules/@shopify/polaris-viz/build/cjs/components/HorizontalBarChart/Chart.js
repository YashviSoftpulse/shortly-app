'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var polarisVizCore = require('@shopify/polaris-viz-core');
var web = require('@react-spring/web');
var index = require('../ChartElements/index.js');
var useFormattedLabels = require('../../hooks/useFormattedLabels.js');
var constants$1 = require('../../constants.js');
var jsxRuntime = require('react/jsx-runtime');
var useColorVisionEvents = require('../../hooks/ColorVisionA11y/useColorVisionEvents.js');
var useHorizontalSeriesColors = require('../../hooks/useHorizontalSeriesColors.js');
var useLegend = require('../LegendContainer/hooks/useLegend.js');
var useDataForHorizontalChart = require('../../hooks/useDataForHorizontalChart.js');
var formatDataIntoGroups = require('../../utilities/formatDataIntoGroups.js');
var useHorizontalStackedValues = require('../../hooks/useHorizontalStackedValues.js');
var useHorizontalXScale = require('../../hooks/useHorizontalXScale.js');
var useHorizontalBarSizes = require('../../hooks/useHorizontalBarSizes.js');
var useBarChartTooltipContent = require('../../hooks/useBarChartTooltipContent.js');
var useHorizontalTransitions = require('../../hooks/useHorizontalTransitions.js');
var checkAvailableAnnotations = require('../Annotations/utilities/checkAvailableAnnotations.js');
var VerticalGridLines = require('./components/VerticalGridLines/VerticalGridLines.js');
var HorizontalBarChartXAxisLabels = require('../HorizontalBarChartXAxisLabels/HorizontalBarChartXAxisLabels.js');
var GradientDefs = require('../shared/GradientDefs/GradientDefs.js');
var HorizontalGroup = require('../shared/HorizontalGroup/HorizontalGroup.js');
var HorizontalBarChartXAnnotations = require('./components/HorizontalBarChartXAnnotations/HorizontalBarChartXAnnotations.js');
var HorizontalBarChartYAnnotations = require('./components/HorizontalBarChartYAnnotations/HorizontalBarChartYAnnotations.js');
var TooltipWrapper = require('../TooltipWrapper/TooltipWrapper.js');
var getAlteredHorizontalBarPosition = require('./utilities/getAlteredHorizontalBarPosition.js');
var LegendContainer = require('../LegendContainer/LegendContainer.js');
var eventPoint = require('../../utilities/eventPoint.js');
var constants = require('../TooltipWrapper/constants.js');

function Chart({
  annotationsLookupTable,
  data,
  dimensions,
  renderHiddenLegendLabel,
  renderLegendContent,
  renderTooltipContent,
  seriesNameFormatter,
  showLegend,
  type,
  xAxisOptions,
  yAxisOptions
}) {
  useColorVisionEvents.useColorVisionEvents({
    enabled: data.length > 1
  });
  const selectedTheme = polarisVizCore.useTheme();
  const id = React.useMemo(() => polarisVizCore.uniqueId('HorizontalBarChart'), []);
  const isStacked = type === 'stacked';
  const [svgRef, setSvgRef] = React.useState(null);
  const [xAxisHeight, setXAxisHeight] = React.useState(polarisVizCore.LINE_HEIGHT);
  const [annotationsHeight, setAnnotationsHeight] = React.useState(0);
  const {
    longestSeriesCount,
    seriesColors
  } = useHorizontalSeriesColors.useHorizontalSeriesColors(data);
  const {
    legend,
    setLegendDimensions,
    height,
    width
  } = useLegend.useLegend({
    data: [{
      shape: 'Bar',
      series: data
    }],
    dimensions,
    showLegend,
    colors: seriesColors,
    seriesNameFormatter
  });
  const {
    allNumbers,
    longestLabel,
    areAllNegative
  } = useDataForHorizontalChart.useDataForHorizontalChart({
    data,
    isSimple: false,
    isStacked,
    labelFormatter: xAxisOptions.labelFormatter
  });
  const highestValueForSeries = React.useMemo(() => {
    const groups = formatDataIntoGroups.formatDataIntoGroups(data);
    const maxes = groups.map(numbers => {
      const values = numbers.map(value => value).filter(Boolean);

      if (values.length === 0) {
        return 0;
      }

      return areAllNegative ? Math.min(...values) : Math.max(...values);
    });
    return maxes;
  }, [data, areAllNegative]);
  const {
    stackedValues,
    stackedMin,
    stackedMax
  } = useHorizontalStackedValues.useHorizontalStackedValues({
    isStacked,
    data
  });
  const chartYPosition = polarisVizCore.ChartMargin.Top + annotationsHeight;
  const drawableHeight = height - xAxisHeight - chartYPosition;
  const {
    xScale,
    ticks,
    ticksFormatted,
    drawableWidth,
    chartXPosition
  } = useHorizontalXScale.useHorizontalXScale({
    allNumbers,
    stackedMin,
    stackedMax,
    isStacked,
    maxWidth: width - longestLabel.negative - longestLabel.positive,
    labelFormatter: xAxisOptions.labelFormatter,
    longestLabel
  });
  const {
    barHeight,
    chartHeight,
    groupBarsAreaHeight,
    groupHeight
  } = useHorizontalBarSizes.useHorizontalBarSizes({
    chartDimensions: {
      width: drawableWidth,
      height: drawableHeight
    },
    isSimple: xAxisOptions.hide,
    isStacked,
    seriesLength: longestSeriesCount,
    singleBarCount: data.length,
    xAxisHeight
  });
  const annotationsDrawableHeight = chartYPosition + chartHeight + constants$1.ANNOTATIONS_LABELS_OFFSET;
  const getTooltipMarkup = useBarChartTooltipContent.useBarChartTooltipContent({
    data,
    seriesColors,
    renderTooltipContent,
    seriesNameFormatter
  });
  const {
    transitions
  } = useHorizontalTransitions.useHorizontalTransitions({
    series: data,
    groupHeight,
    chartXPosition
  });
  const zeroPosition = longestLabel.negative + xScale(0);
  const labelWidth = drawableWidth / ticks.length;
  const chartBounds = {
    width,
    height,
    x: chartXPosition,
    y: 0
  };
  const {
    hasXAxisAnnotations,
    hasYAxisAnnotations
  } = checkAvailableAnnotations.checkAvailableAnnotations(annotationsLookupTable);
  const {
    unformattedLabels
  } = useFormattedLabels.useFormattedLabels({
    data,
    labelFormatter: yAxisOptions.labelFormatter
  });
  const getAriaLabel = polarisVizCore.useAriaLabel(data, {
    xAxisLabelFormatter: xAxisOptions.labelFormatter,
    yAxisLabelFormatter: yAxisOptions.labelFormatter
  });
  return /*#__PURE__*/jsxRuntime.jsxs(index.ChartElements.Div, {
    height: height,
    width: width,
    children: [/*#__PURE__*/jsxRuntime.jsxs(index.ChartElements.Svg, {
      setRef: setSvgRef,
      width: width,
      height: height,
      children: [xAxisOptions.hide === true ? null : /*#__PURE__*/jsxRuntime.jsxs("g", {
        transform: `translate(${chartXPosition}, ${chartYPosition})`,
        children: [/*#__PURE__*/jsxRuntime.jsx(VerticalGridLines.VerticalGridLines, {
          chartHeight: chartHeight + polarisVizCore.HORIZONTAL_SPACE_BETWEEN_CHART_AND_AXIS,
          stroke: selectedTheme.grid.color,
          ticks: ticks,
          xScale: xScale
        }), /*#__PURE__*/jsxRuntime.jsx(HorizontalBarChartXAxisLabels.HorizontalBarChartXAxisLabels, {
          allowLineWrap: xAxisOptions.allowLineWrap,
          chartX: -labelWidth / 2,
          chartY: drawableHeight,
          labels: ticksFormatted,
          labelWidth: labelWidth,
          onHeightChange: setXAxisHeight,
          ticks: ticks,
          xScale: xScale
        })]
      }), /*#__PURE__*/jsxRuntime.jsx(GradientDefs.GradientDefs, {
        direction: "horizontal",
        gradientUnits: isStacked ? 'objectBoundingBox' : 'userSpaceOnUse',
        id: id,
        seriesColors: seriesColors,
        size: isStacked ? '100%' : `${width}px`
      }), /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${0}, ${chartYPosition})`,
        children: transitions((style, item, _transition, index) => {
          var _item$key;

          const {
            opacity,
            transform
          } = style;
          const name = (_item$key = item.key) !== null && _item$key !== void 0 ? _item$key : '';
          const ariaLabel = getAriaLabel({
            seriesIndex: item.index,
            key: item.key
          });
          return /*#__PURE__*/jsxRuntime.jsx(web.animated.g, {
            style: {
              opacity,
              transform
            },
            children: /*#__PURE__*/jsxRuntime.jsx(HorizontalGroup.HorizontalGroup, {
              areAllNegative: areAllNegative,
              ariaLabel: ariaLabel,
              barHeight: barHeight,
              containerWidth: width,
              data: data,
              groupHeight: groupHeight,
              id: id,
              index: index,
              isSimple: false,
              isStacked: isStacked,
              name: name,
              stackedValues: stackedValues,
              xAxisOptions: xAxisOptions,
              xScale: xScale,
              yAxisOptions: yAxisOptions,
              zeroPosition: zeroPosition
            })
          }, `group-${name}`);
        })
      }), hasXAxisAnnotations && /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition}, ${0})`,
        children: /*#__PURE__*/jsxRuntime.jsx(HorizontalBarChartXAnnotations.HorizontalBarChartXAnnotations, {
          annotationsLookupTable: annotationsLookupTable,
          drawableHeight: annotationsDrawableHeight,
          drawableWidth: drawableWidth,
          onHeightChange: setAnnotationsHeight,
          xScale: xScale
        })
      }), hasYAxisAnnotations && /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition}, ${chartYPosition})`,
        children: /*#__PURE__*/jsxRuntime.jsx(HorizontalBarChartYAnnotations.HorizontalBarChartYAnnotations, {
          annotationsLookupTable: annotationsLookupTable,
          drawableWidth: drawableWidth,
          groupHeight: groupHeight,
          labels: unformattedLabels,
          zeroPosition: zeroPosition
        })
      })]
    }), highestValueForSeries.length !== 0 && /*#__PURE__*/jsxRuntime.jsx(TooltipWrapper.TooltipWrapper, {
      bandwidth: groupBarsAreaHeight,
      chartBounds: chartBounds,
      focusElementDataType: polarisVizCore.DataType.BarGroup,
      getAlteredPosition: getAlteredHorizontalBarPosition.getAlteredHorizontalBarPosition,
      getMarkup: getTooltipMarkup,
      getPosition: getTooltipPosition,
      margin: polarisVizCore.ChartMargin,
      parentRef: svgRef
    }), showLegend && /*#__PURE__*/jsxRuntime.jsx(LegendContainer.LegendContainer, {
      colorVisionType: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
      data: legend,
      dimensions: dimensions,
      enableHideOverflow: true,
      onDimensionChange: setLegendDimensions,
      renderLegendContent: renderLegendContent,
      renderHiddenLegendLabel: renderHiddenLegendLabel
    })]
  });

  function formatPositionForTooltip(index) {
    if (isStacked) {
      const x = stackedValues[index].reduce((prev, cur) => {
        const [start, end] = cur;

        if (start < 0) {
          return prev;
        }

        return prev + (xScale(end) - xScale(start));
      }, xScale(0));
      return {
        x,
        y: groupHeight * index,
        activeIndex: index
      };
    }

    const highestValue = highestValueForSeries[index];
    const x = chartXPosition + xScale(highestValue);
    return {
      x: highestValue < 0 ? -x : x,
      y: groupHeight * index,
      activeIndex: index
    };
  }

  function getTooltipPosition({
    event,
    index,
    eventType
  }) {
    if (eventType === 'mouse' && event) {
      const point = eventPoint.eventPointNative(event);

      if (point == null) {
        return constants.TOOLTIP_POSITION_DEFAULT_RETURN;
      }

      const {
        svgY
      } = point;
      const currentPoint = svgY - 0;
      const currentIndex = Math.floor(currentPoint / groupHeight);

      if (currentIndex < 0 || currentIndex > longestSeriesCount - 1) {
        return constants.TOOLTIP_POSITION_DEFAULT_RETURN;
      }

      return formatPositionForTooltip(currentIndex);
    } else if (index != null) {
      return formatPositionForTooltip(index);
    }

    return constants.TOOLTIP_POSITION_DEFAULT_RETURN;
  }
}

exports.Chart = Chart;
