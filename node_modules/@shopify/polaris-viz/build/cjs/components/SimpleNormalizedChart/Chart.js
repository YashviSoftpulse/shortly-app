'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var d3Array = require('d3-array');
var d3Scale = require('d3-scale');
var polarisVizCore = require('@shopify/polaris-viz-core');
var useThemeSeriesColors = require('../../hooks/useThemeSeriesColors.js');
var constants = require('../../constants.js');
var SimpleNormalizedChart = require('./SimpleNormalizedChart.scss.js');
var jsxRuntime = require('react/jsx-runtime');
var useColorVisionEvents = require('../../hooks/ColorVisionA11y/useColorVisionEvents.js');
var useWatchColorVisionEvents = require('../../hooks/ColorVisionA11y/useWatchColorVisionEvents.js');
var classnames = require('../../utilities/classnames.js');
var BarSegment = require('./components/BarSegment/BarSegment.js');
var BarLabel = require('./components/BarLabel/BarLabel.js');

function Chart({
  comparisonMetrics = [],
  data,
  labelFormatter,
  legendPosition = 'top-left',
  seriesNameFormatter,
  direction = 'horizontal',
  size = 'small',
  showLegend = true,
  renderLegendContent
}) {
  const flattenedData = data.map(({
    data
  }) => data).flat();
  useColorVisionEvents.useColorVisionEvents();
  const selectedTheme = polarisVizCore.useTheme();
  const colors = useThemeSeriesColors.useThemeSeriesColors(data, selectedTheme);
  const containsNegatives = flattenedData.some(({
    value
  }) => value !== null && value < 0);
  const [activeIndex, setActiveIndex] = React.useState(-1);
  useWatchColorVisionEvents.useWatchColorVisionEvents({
    type: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => setActiveIndex(detail.index)
  });

  if (constants.WARN_FOR_DEVELOPMENT && containsNegatives) {
    // eslint-disable-next-line no-console
    console.warn('This component is not built to handle negatives. Consider using a different component.');
  }

  if (constants.WARN_FOR_DEVELOPMENT && flattenedData.length > 4) {
    throw new Error('This component displays a max of 4 data items. Please modify your data before passing it into this component.');
  }

  const slicedData = flattenedData.slice(0, 4);
  const totalValue = d3Array.sum(slicedData, ({
    value
  }) => value);
  const xScale = d3Scale.scaleLinear().range([0, 100]).domain([0, totalValue]);
  const isVertical = direction === 'vertical';
  const bars = isVertical ? slicedData.reverse() : slicedData;
  const isEmptyValues = slicedData.every(({
    value
  }) => !value);
  const isRightLabel = legendPosition.includes('right');
  const isBottomLabel = legendPosition.includes('bottom');
  const isVerticalAndRightLabel = isVertical && isRightLabel;
  const isVerticalAndBottomLabel = isVertical && isBottomLabel;
  const isHorizontalAndRightLabel = !isVertical && isRightLabel;
  const isHorizontalAndBottomLabel = !isVertical && isBottomLabel;

  const legendMarkup = () => {
    if (!showLegend) {
      return null;
    }

    if (renderLegendContent) {
      const colorVisionInteractionMethods = {
        getColorVisionStyles: index => polarisVizCore.getColorVisionStylesForActiveIndex({
          activeIndex,
          index
        }),
        getColorVisionEventAttrs: index => polarisVizCore.getColorVisionEventAttrs({
          type: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
          index
        })
      };
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: classnames.classNames(isVertical ? SimpleNormalizedChart["default"].VerticalLabelContainer : SimpleNormalizedChart["default"].HorizontalLabelContainer, (isVerticalAndBottomLabel || isHorizontalAndRightLabel) && SimpleNormalizedChart["default"].LabelContainerEndJustify),
        children: renderLegendContent(colorVisionInteractionMethods)
      });
    }

    return /*#__PURE__*/jsxRuntime.jsx("ul", {
      className: classnames.classNames(...(isVertical ? [SimpleNormalizedChart["default"].VerticalLabelContainer] : [SimpleNormalizedChart["default"].HorizontalLabelContainer, SimpleNormalizedChart["default"].HorizontalLabelContainerGrid]), (isVerticalAndBottomLabel || isHorizontalAndRightLabel) && SimpleNormalizedChart["default"].LabelContainerEndJustify),
      children: slicedData.map(({
        key,
        value
      }, index) => {
        var _data$index$name$toSt, _data$index$name;

        if (value == null) {
          return null;
        }

        const comparisonMetric = comparisonMetrics.find(({
          dataIndex
        }) => index === dataIndex);
        const formattedValue = labelFormatter(value);
        const formattedName = seriesNameFormatter((_data$index$name$toSt = (_data$index$name = data[index].name) === null || _data$index$name === void 0 ? void 0 : _data$index$name.toString()) !== null && _data$index$name$toSt !== void 0 ? _data$index$name$toSt : '');
        return /*#__PURE__*/jsxRuntime.jsx(BarLabel.BarLabel, {
          activeIndex: activeIndex,
          index: index,
          label: formattedName,
          value: formattedValue,
          color: colors[index],
          comparisonMetric: comparisonMetric,
          direction: direction,
          legendPosition: legendPosition
        }, `${key}-${formattedValue}-${index}`);
      })
    });
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classnames.classNames(SimpleNormalizedChart["default"].Container, isVertical ? SimpleNormalizedChart["default"].VerticalContainer : SimpleNormalizedChart["default"].HorizontalContainer, isVerticalAndRightLabel && SimpleNormalizedChart["default"].VerticalContainerRightLabel, isHorizontalAndBottomLabel && SimpleNormalizedChart["default"].HorizontalContainerBottomLabel),
    children: [legendMarkup(), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: classnames.classNames(SimpleNormalizedChart["default"].BarContainer, isVertical ? SimpleNormalizedChart["default"].VerticalBarContainer : SimpleNormalizedChart["default"].HorizontalBarContainer),
      children: isEmptyValues ? /*#__PURE__*/jsxRuntime.jsx(BarSegment.BarSegment, {
        activeIndex: -1,
        index: -1,
        direction: direction,
        size: size,
        scale: 100,
        color: selectedTheme.seriesColors.empty,
        roundedCorners: selectedTheme.bar.borderRadius
      }, "empty-bar") : bars.map(({
        value,
        key
      }, index) => {
        if (value == null || value === 0) {
          return null;
        }

        const colorIndex = isVertical ? bars.length - 1 - index : index;
        return /*#__PURE__*/jsxRuntime.jsx(BarSegment.BarSegment, {
          activeIndex: activeIndex,
          index: colorIndex,
          direction: direction,
          size: size,
          scale: xScale(value),
          color: colors[colorIndex],
          roundedCorners: selectedTheme.bar.borderRadius
        }, `${key}-${index}`);
      })
    })]
  });
}

exports.Chart = Chart;
