'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var d3Shape = require('d3-shape');
var polarisVizCore = require('@shopify/polaris-viz-core');
var getAnimationDelayForItems = require('../../utilities/getAnimationDelayForItems.js');
var DonutChart = require('./DonutChart.scss.js');
var jsxRuntime = require('react/jsx-runtime');
var useLegend = require('../LegendContainer/hooks/useLegend.js');
var useColorVisionEvents = require('../../hooks/ColorVisionA11y/useColorVisionEvents.js');
var useWatchColorVisionEvents = require('../../hooks/ColorVisionA11y/useWatchColorVisionEvents.js');
var getContainerAlignmentForLegend = require('../../utilities/getContainerAlignmentForLegend.js');
var Arc = require('../Arc/Arc.js');
var InnerValue = require('./components/InnerValue/InnerValue.js');
var ChartSkeleton = require('../ChartSkeleton/ChartSkeleton.js');
var LegendContainer = require('../LegendContainer/LegendContainer.js');
var LegendValues = require('./components/LegendValues/LegendValues.js');

const FULL_CIRCLE = Math.PI * 2;
const RADIUS_PADDING = 20;
const SMALL_CHART_HEIGHT_THRESHOLD = 150;
function Chart({
  data,
  labelFormatter,
  legendPosition = 'right',
  showLegend,
  showLegendValues,
  state,
  theme,
  accessibilityLabel = '',
  comparisonMetric,
  dimensions = {
    height: 0,
    width: 0
  },
  errorText,
  legendFullWidth = false,
  renderInnerValueContent,
  renderLegendContent,
  renderHiddenLegendLabel,
  seriesNameFormatter,
  total
}) {
  var _points$activeIndex;

  const {
    shouldAnimate
  } = polarisVizCore.useChartContext();
  const chartId = polarisVizCore.useUniqueId('Donut');
  const [activeIndex, setActiveIndex] = React.useState(-1);
  const selectedTheme = polarisVizCore.useTheme();
  const seriesCount = polarisVizCore.clamp({
    amount: data.length,
    min: 1,
    max: Infinity
  });
  const seriesColor = polarisVizCore.getSeriesColors(seriesCount, selectedTheme);
  const legendDirection = legendPosition === 'right' || legendPosition === 'left' ? 'vertical' : 'horizontal';
  const maxLegendWidth = legendDirection === 'vertical' ? dimensions.width / 2 : 0;
  const {
    height,
    width,
    legend,
    setLegendDimensions,
    isLegendMounted
  } = useLegend.useLegend({
    data: [{
      series: data,
      shape: 'Bar'
    }],
    dimensions,
    showLegend,
    direction: legendDirection,
    colors: seriesColor,
    maxWidth: maxLegendWidth,
    seriesNameFormatter
  });
  const shouldUseColorVisionEvents = Boolean(width && height && isLegendMounted);
  useColorVisionEvents.useColorVisionEvents({
    enabled: shouldUseColorVisionEvents,
    dimensions: { ...dimensions,
      x: 0,
      y: 0
    }
  });
  useWatchColorVisionEvents.useWatchColorVisionEvents({
    type: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => {
      setActiveIndex(detail.index);
    }
  });

  if (!width || !height) {
    return null;
  }

  const diameter = Math.min(height, width);
  const radius = diameter / 2;
  const dynamicThickness = height / 10;
  const maxThickness = selectedTheme.arc.thickness;
  const thickness = height > SMALL_CHART_HEIGHT_THRESHOLD ? Math.min(dynamicThickness, maxThickness) : polarisVizCore.THIN_ARC_CORNER_THICKNESS;
  const points = data.reduce((prev, {
    data
  }) => prev.concat(data), []);
  const createPie = d3Shape.pie().value(({
    value
  }) => value).sort(null);
  const pieChartData = createPie(points);
  const isEveryValueZero = points.every(({
    value
  }) => value === 0);
  const emptyState = pieChartData.length === 0 || isEveryValueZero;
  const totalValue = total || points.reduce((acc, {
    value
  }) => (value !== null && value !== void 0 ? value : 0) + acc, 0);
  const activeValue = (_points$activeIndex = points[activeIndex]) === null || _points$activeIndex === void 0 ? void 0 : _points$activeIndex.value;
  const minX = -40;
  const minY = -40;
  const viewBoxDimensions = {
    height: diameter + RADIUS_PADDING,
    width: diameter + RADIUS_PADDING
  };
  const containerAlignmentStyle = getContainerAlignmentForLegend.getContainerAlignmentForLegend(legendPosition);
  const dynamicStyles = { ...containerAlignmentStyle,
    gap: legendDirection === 'vertical' ? '16px' : undefined
  };

  const renderLegendContentWithValues = ({
    getColorVisionStyles,
    getColorVisionEventAttrs
  }) => {
    return /*#__PURE__*/jsxRuntime.jsx(LegendValues.LegendValues, {
      data: data,
      activeIndex: activeIndex,
      dimensions: { ...dimensions,
        x: 0,
        y: 0
      },
      legendFullWidth: legendFullWidth,
      labelFormatter: labelFormatter,
      getColorVisionStyles: getColorVisionStyles,
      getColorVisionEventAttrs: getColorVisionEventAttrs,
      renderHiddenLegendLabel: renderHiddenLegendLabel,
      seriesNameFormatter: seriesNameFormatter
    });
  };

  const shouldRenderLegendContentWithValues = !renderLegendContent && showLegendValues && legendDirection === 'vertical';
  const isCornerPosition = legendPosition.includes('-');
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: DonutChart["default"].DonutWrapper,
    style: dynamicStyles,
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      className: DonutChart["default"].Donut,
      children: state === polarisVizCore.ChartState.Success ? /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx("span", {
          className: DonutChart["default"].VisuallyHidden,
          children: accessibilityLabel
        }), /*#__PURE__*/jsxRuntime.jsx("svg", {
          viewBox: `${minX} ${minY} ${viewBoxDimensions.width} ${viewBoxDimensions.height}`,
          height: diameter,
          width: diameter,
          children: isLegendMounted && /*#__PURE__*/jsxRuntime.jsx("g", {
            className: DonutChart["default"].DonutChart,
            children: emptyState ? /*#__PURE__*/jsxRuntime.jsx("g", {
              "aria-hidden": true,
              children: /*#__PURE__*/jsxRuntime.jsx(Arc.Arc, {
                isAnimated: shouldAnimate,
                width: diameter,
                height: diameter,
                radius: radius,
                startAngle: 0,
                endAngle: FULL_CIRCLE,
                color: selectedTheme.grid.color,
                cornerRadius: selectedTheme.arc.cornerRadius,
                thickness: thickness
              })
            }) : pieChartData.map(({
              data: pieData,
              startAngle,
              endAngle
            }, index) => {
              var _data$index$color, _data$index;

              const color = (_data$index$color = (_data$index = data[index]) === null || _data$index === void 0 ? void 0 : _data$index.color) !== null && _data$index$color !== void 0 ? _data$index$color : seriesColor[index];
              const name = data[index].name;
              const accessibilityLabel = `${name}: ${pieData.key} - ${pieData.value}`;
              return /*#__PURE__*/jsxRuntime.jsx("g", {
                className: DonutChart["default"].DonutChart,
                "aria-label": accessibilityLabel,
                role: "img",
                children: /*#__PURE__*/jsxRuntime.jsx(Arc.Arc, {
                  isAnimated: shouldAnimate,
                  animationDelay: getAnimationDelayForItems.getAnimationDelayForItems(pieChartData.length),
                  index: index,
                  activeIndex: activeIndex,
                  width: diameter,
                  height: diameter,
                  radius: radius,
                  startAngle: startAngle,
                  endAngle: endAngle,
                  color: color,
                  cornerRadius: selectedTheme.arc.cornerRadius,
                  thickness: thickness
                })
              }, `${chartId}-arc-${index}`);
            })
          })
        }), /*#__PURE__*/jsxRuntime.jsx(InnerValue.InnerValue, {
          activeValue: activeValue,
          activeIndex: activeIndex,
          isAnimated: shouldAnimate,
          totalValue: totalValue,
          comparisonMetric: comparisonMetric,
          labelFormatter: labelFormatter,
          renderInnerValueContent: renderInnerValueContent,
          diameter: diameter,
          dimensions: dimensions
        })]
      }) : /*#__PURE__*/jsxRuntime.jsx(ChartSkeleton.ChartSkeleton, {
        dimensions: {
          width: diameter,
          height: diameter
        },
        state: state,
        type: "Donut",
        errorText: errorText,
        theme: theme
      })
    }), showLegend && /*#__PURE__*/jsxRuntime.jsx(LegendContainer.LegendContainer, {
      fullWidth: legendFullWidth,
      onDimensionChange: setLegendDimensions,
      colorVisionType: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
      data: legend,
      direction: legendDirection,
      position: legendPosition,
      maxWidth: maxLegendWidth,
      enableHideOverflow: !isCornerPosition,
      dimensions: { ...dimensions,
        x: 0,
        y: 0
      },
      renderLegendContent: shouldRenderLegendContentWithValues ? renderLegendContentWithValues : renderLegendContent
    })]
  });
}

exports.Chart = Chart;
