'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var isEqual = require('fast-deep-equal');
var polarisVizCore = require('@shopify/polaris-viz-core');
var constants = require('../../constants.js');
var LegendContainer$1 = require('./LegendContainer.scss.js');
var HiddenLegendTooltip = require('./components/HiddenLegendTooltip.js');
var useOverflowLegend = require('./hooks/useOverflowLegend.js');
var jsxRuntime = require('react/jsx-runtime');
var useResizeObserver = require('../../hooks/useResizeObserver.js');
var useWatchColorVisionEvents = require('../../hooks/ColorVisionA11y/useWatchColorVisionEvents.js');
var classnames = require('../../utilities/classnames.js');
var Legend = require('../Legend/Legend.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);

function LegendContainer({
  colorVisionType,
  data: allData,
  onDimensionChange,
  direction = 'horizontal',
  fullWidth = false,
  position = 'bottom',
  maxWidth,
  renderLegendContent,
  enableHideOverflow = false,
  renderHiddenLegendLabel = count => `+${count} more`,
  dimensions
}) {
  var _renderLegendContent;

  const selectedTheme = polarisVizCore.useTheme();
  const {
    setRef,
    entry
  } = useResizeObserver.useResizeObserver();
  const {
    theme
  } = polarisVizCore.useChartContext();
  const previousHeight = React.useRef(constants.DEFAULT_LEGEND_HEIGHT);
  const previousWidth = React.useRef(constants.DEFAULT_LEGEND_WIDTH);
  const [activeIndex, setActiveIndex] = React.useState(-1);
  const isPositionTop = position.includes('top');
  const isPositionLeft = position.includes('left');
  const {
    horizontalMargin
  } = selectedTheme.grid;
  const leftMargin = isPositionLeft ? 0 : horizontalMargin;
  const legendItemDimensions = React.useRef([{
    width: 0,
    height: 0
  }]);
  const [activatorWidth, setActivatorWidth] = React.useState(0);
  const overflowLegendProps = direction === 'horizontal' ? {
    direction: 'horizontal',
    data: allData,
    enableHideOverflow,
    legendItemDimensions,
    width: (dimensions === null || dimensions === void 0 ? void 0 : dimensions.width) || 0,
    activatorWidth,
    leftMargin,
    horizontalMargin
  } : {
    direction: 'vertical',
    data: allData,
    height: dimensions === null || dimensions === void 0 ? void 0 : dimensions.height,
    enableHideOverflow,
    legendItemDimensions
  };
  const {
    displayedData,
    hiddenData
  } = useOverflowLegend.useOverflowLegend(overflowLegendProps);
  const hasHiddenData = enableHideOverflow && displayedData.length < allData.length;
  const styleMap = {
    horizontal: {
      justifyContent: 'flex-end',
      margin: isPositionTop ? `0 ${horizontalMargin}px ${polarisVizCore.LEGENDS_BOTTOM_MARGIN}px ${leftMargin}px` : `${polarisVizCore.LEGENDS_TOP_MARGIN}px ${horizontalMargin}px 0 ${leftMargin}px`,
      flexDirection: 'row',
      flexWrap: enableHideOverflow ? 'nowrap' : 'wrap'
    },
    vertical: {
      alignItems: 'flex-start',
      margin: `0 ${horizontalMargin}px 0 ${leftMargin}px`,
      flexDirection: 'column',
      maxWidth: fullWidth ? 'none' : maxWidth,
      flex: fullWidth ? 1 : 'initial'
    },
    centerTiles: {
      justifyContent: 'center'
    }
  };

  const shouldCenterTiles = pos => {
    if (pos === 'top' || pos === 'bottom') {
      return {
        justifyContent: 'center'
      };
    }
  };

  const colorVisionInteractionMethods = {
    getColorVisionStyles: index => polarisVizCore.getColorVisionStylesForActiveIndex({
      activeIndex,
      index
    }),
    getColorVisionEventAttrs: index => polarisVizCore.getColorVisionEventAttrs({
      type: colorVisionType,
      index
    })
  };
  useWatchColorVisionEvents.useWatchColorVisionEvents({
    type: colorVisionType,
    onIndexChange: ({
      detail
    }) => {
      setActiveIndex(detail.index);
    }
  });
  React.useEffect(() => {
    const newHeight = entry === null || entry === void 0 ? void 0 : entry.contentRect.height;
    const newWidth = entry === null || entry === void 0 ? void 0 : entry.contentRect.width;
    const newDimensions = {
      height: newHeight,
      width: newWidth
    };

    if (entry == null || newHeight == null || newWidth == null) {
      return;
    }

    if (isEqual__default["default"]({
      height: previousHeight.current,
      width: previousWidth.current
    }, newDimensions)) {
      return;
    }

    previousHeight.current = newDimensions.height;
    previousWidth.current = newDimensions.width;
    onDimensionChange(newDimensions);
  }, [entry, onDimensionChange]);
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: classnames.classNames(LegendContainer$1["default"].Container),
    ref: setRef,
    role: "list",
    style: { ...styleMap[direction],
      ...shouldCenterTiles(position)
    },
    children: (_renderLegendContent = renderLegendContent === null || renderLegendContent === void 0 ? void 0 : renderLegendContent(colorVisionInteractionMethods)) !== null && _renderLegendContent !== void 0 ? _renderLegendContent : /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
      children: [/*#__PURE__*/jsxRuntime.jsx(Legend.Legend, {
        activeIndex: activeIndex,
        colorVisionType: colorVisionType,
        data: hasHiddenData ? displayedData : allData,
        theme: theme,
        itemDimensions: enableHideOverflow ? legendItemDimensions : undefined,
        truncate: hasHiddenData
      }), hasHiddenData && /*#__PURE__*/jsxRuntime.jsx(HiddenLegendTooltip.HiddenLegendTooltip, {
        activeIndex: activeIndex,
        colorVisionType: colorVisionType,
        data: hiddenData,
        theme: theme,
        label: renderHiddenLegendLabel(allData.length - displayedData.length),
        lastVisibleIndex: allData.length - hiddenData.length,
        setActivatorWidth: setActivatorWidth,
        dimensions: dimensions
      })]
    })
  });
}

exports.LegendContainer = LegendContainer;
