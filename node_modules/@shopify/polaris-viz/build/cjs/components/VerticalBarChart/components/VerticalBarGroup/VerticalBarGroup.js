'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var polarisVizCore = require('@shopify/polaris-viz-core');
var React = require('react');
var getLoadAnimationDelay = require('../../../../utilities/getLoadAnimationDelay.js');
var getChartId = require('../../../../utilities/getChartId.js');
var applyColorVisionToDomElement = require('../../../../utilities/applyColorVisionToDomElement.js');
var jsxRuntime = require('react/jsx-runtime');
var useWatchColorVisionEvents = require('../../../../hooks/ColorVisionA11y/useWatchColorVisionEvents.js');
var StackedBarGroups = require('../StackedBarGroups/StackedBarGroups.js');
var BarGroup = require('../BarGroup/BarGroup.js');

function VerticalBarGroup({
  colors,
  data,
  drawableHeight,
  gapWidth,
  id,
  indexOffset = 0,
  labels,
  sortedData,
  stackedValues,
  xScale,
  yScale,
  yAxisOptions,
  areAllNegative
}) {
  const {
    id: chartId,
    isPerformanceImpacted
  } = polarisVizCore.useChartContext();
  const [activeBarGroup, setActiveBarGroup] = React.useState(-1);
  const groupElements = React.useMemo(() => {
    const chart = document.getElementById(getChartId.getChartId(chartId));

    if (chart == null) {
      return [];
    }

    return chart.querySelectorAll(`[data-type="${polarisVizCore.DataType.BarGroup}"]`); // We want this to run whenever colors change so we
    // get all the groups again.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [sortedData]);
  useWatchColorVisionEvents.useWatchColorVisionEvents({
    type: polarisVizCore.COLOR_VISION_GROUP_ITEM,
    onIndexChange: ({
      detail
    }) => {
      setActiveBarGroup(detail.index);
      groupElements.forEach(element => {
        applyColorVisionToDomElement.applyColorVisionToDomElement({
          element,
          activeIndex: detail.index,
          isPerformanceImpacted
        });
      });
    }
  });
  const accessibilityData = React.useMemo(() => labels.map((title, index) => {
    const content = data.map(({
      data,
      name
    }) => {
      var _data$index$value;

      return {
        label: name !== null && name !== void 0 ? name : '',
        value: yAxisOptions.labelFormatter((_data$index$value = data[index].value) !== null && _data$index$value !== void 0 ? _data$index$value : 0)
      };
    });
    return {
      title,
      data: content
    };
  }), [data, labels, yAxisOptions]);

  if (stackedValues != null) {
    return /*#__PURE__*/jsxRuntime.jsx(StackedBarGroups.StackedBarGroups, {
      accessibilityData: accessibilityData,
      activeBarGroup: activeBarGroup,
      colors: colors,
      drawableHeight: drawableHeight,
      gapWidth: gapWidth,
      id: id,
      labels: labels,
      stackedValues: stackedValues,
      xScale: xScale,
      yScale: yScale
    });
  }

  return /*#__PURE__*/jsxRuntime.jsx(React.Fragment, {
    children: sortedData.map((item, index) => {
      const xPosition = xScale(index.toString());
      const animationDelay = getLoadAnimationDelay.getLoadAnimationDelay(index, sortedData.length);
      return /*#__PURE__*/jsxRuntime.jsx(BarGroup.BarGroup, {
        accessibilityData: accessibilityData,
        activeBarGroup: activeBarGroup,
        animationDelay: animationDelay,
        barGroupIndex: index,
        colors: colors,
        data: item,
        gapWidth: gapWidth,
        drawableHeight: drawableHeight,
        indexOffset: indexOffset,
        width: xScale.bandwidth(),
        x: xPosition == null ? 0 : xPosition,
        yScale: yScale,
        areAllNegative: areAllNegative
      }, index);
    })
  });
}

exports.VerticalBarGroup = VerticalBarGroup;
