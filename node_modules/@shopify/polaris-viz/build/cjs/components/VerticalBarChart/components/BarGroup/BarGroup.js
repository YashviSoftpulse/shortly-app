'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var polarisVizCore = require('@shopify/polaris-viz-core');
var getChartId = require('../../../../utilities/getChartId.js');
var applyColorVisionToDomElement = require('../../../../utilities/applyColorVisionToDomElement.js');
var BarGroup$1 = require('./BarGroup.scss.js');
var jsxRuntime = require('react/jsx-runtime');
var formatAriaLabel = require('../../utilities/formatAriaLabel.js');
var useWatchColorVisionEvents = require('../../../../hooks/ColorVisionA11y/useWatchColorVisionEvents.js');
var VerticalBar = require('../VerticalBar/VerticalBar.js');
var getHoverZoneOffset = require('../../../../utilities/getHoverZoneOffset.js');

const COLOR_VISION_MASK = 'colorVisionMask';
function BarGroup({
  animationDelay,
  x,
  data,
  yScale,
  width,
  colors,
  drawableHeight,
  indexOffset,
  barGroupIndex,
  accessibilityData,
  activeBarGroup,
  gapWidth,
  theme,
  areAllNegative
}) {
  const groupAriaLabel = formatAriaLabel.formatAriaLabel(accessibilityData[barGroupIndex]);
  const {
    id,
    isPerformanceImpacted
  } = polarisVizCore.useChartContext();
  const selectedTheme = polarisVizCore.useTheme(theme);
  const maskItems = React.useMemo(() => {
    const chart = document.getElementById(getChartId.getChartId(id));

    if (chart == null) {
      return [];
    }

    return chart.querySelectorAll(`[data-type="${COLOR_VISION_MASK}"][data-group-index="${barGroupIndex}"]`); // We want this to run whenever colors change so we
    // get all the mask items again.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [colors]);
  useWatchColorVisionEvents.useWatchColorVisionEvents({
    type: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => {
      if (detail.index === -1 || activeBarGroup === -1 || activeBarGroup === barGroupIndex) {
        maskItems.forEach(element => {
          applyColorVisionToDomElement.applyColorVisionToDomElement({
            element,
            activeIndex: detail.index,
            isPerformanceImpacted
          });
        });
      }
    }
  });
  const dataLength = polarisVizCore.clamp({
    amount: data.length,
    min: 1,
    max: Infinity
  });
  const barWidth = width / dataLength;
  const getBarHeight = React.useCallback(rawValue => {
    return Math.abs(yScale(rawValue) - yScale(0));
  }, [yScale]);
  const gradientId = React.useMemo(() => polarisVizCore.uniqueId('gradient'), []);
  const maskId = React.useMemo(() => polarisVizCore.uniqueId('mask'), []);
  const gradients = colors.map(color => {
    return typeof color === 'string' ? [{
      color,
      offset: 0
    }] : color;
  });
  return /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx("mask", {
      id: maskId,
      children: data.map((rawValue, index) => {
        if (rawValue == null) {
          return null;
        }

        return /*#__PURE__*/jsxRuntime.jsx("g", {
          className: BarGroup$1["default"].BarGroup,
          "data-type": polarisVizCore.DataType.BarGroup,
          "data-index": barGroupIndex,
          children: /*#__PURE__*/jsxRuntime.jsx(VerticalBar.VerticalBar, {
            height: getBarHeight(rawValue),
            color: polarisVizCore.MASK_HIGHLIGHT_COLOR,
            x: x + (barWidth + polarisVizCore.BAR_SPACING) * index,
            zeroPosition: yScale(0),
            rawValue: rawValue,
            width: barWidth,
            index: index,
            animationDelay: animationDelay,
            areAllNegative: areAllNegative
          })
        }, `${barGroupIndex}${index}`);
      })
    }), /*#__PURE__*/jsxRuntime.jsx("g", {
      mask: `url(#${maskId})`,
      children: gradients.map((gradient, index) => {
        return /*#__PURE__*/jsxRuntime.jsxs("g", {
          children: [/*#__PURE__*/jsxRuntime.jsx(polarisVizCore.LinearGradientWithStops, {
            gradient: gradient,
            id: `${gradientId}${index}`
          }), /*#__PURE__*/jsxRuntime.jsx("rect", {
            x: x + (barWidth + polarisVizCore.BAR_SPACING) * index,
            y: polarisVizCore.SHAPE_ANIMATION_HEIGHT_BUFFER * -1,
            width: barWidth - polarisVizCore.BAR_SPACING,
            height: drawableHeight + polarisVizCore.SHAPE_ANIMATION_HEIGHT_BUFFER * 2,
            "data-type": COLOR_VISION_MASK,
            "data-index": index,
            "data-group-index": barGroupIndex,
            fill: data[index] === 0 ? selectedTheme.bar.zeroValueColor : `url(#${gradientId}${index})`
          })]
        }, `${maskId}${index}`);
      })
    }), /*#__PURE__*/jsxRuntime.jsxs("g", { ...polarisVizCore.getColorVisionEventAttrs({
        type: polarisVizCore.COLOR_VISION_GROUP_ITEM,
        index: barGroupIndex
      }),
      className: BarGroup$1["default"].BarGroup,
      "data-type": polarisVizCore.DataType.BarGroup,
      "data-index": barGroupIndex,
      "aria-hidden": "false",
      "aria-label": groupAriaLabel,
      role: "list",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        width: barWidth * dataLength + gapWidth,
        x: x - gapWidth / 2,
        height: drawableHeight,
        fill: "transparent",
        "aria-hidden": "true"
      }), data.map((rawValue, index) => {
        if (rawValue === null) {
          return null;
        }

        const {
          label,
          value
        } = accessibilityData[barGroupIndex].data[index];
        const ariaLabel = `${label} ${value}`;
        const height = polarisVizCore.clamp({
          amount: Math.abs(yScale(rawValue) - yScale(0)),
          min: 1,
          max: Infinity
        });
        const isNegative = rawValue < 0;
        const y = isNegative ? yScale(0) : yScale(0) - height;
        const {
          clampedSize,
          offset
        } = getHoverZoneOffset.getHoverZoneOffset({
          barSize: height,
          zeroPosition: yScale(0),
          max: drawableHeight,
          position: 'vertical'
        });
        return /*#__PURE__*/jsxRuntime.jsx("rect", {
          height: clampedSize,
          x: x + barWidth * index,
          y: isNegative || areAllNegative ? y : y - offset,
          width: barWidth,
          fill: "transparent",
          "aria-label": ariaLabel,
          role: "listitem",
          ...polarisVizCore.getColorVisionEventAttrs({
            type: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
            index: index + indexOffset,
            watch: !isPerformanceImpacted
          }),
          className: BarGroup$1["default"].Bar,
          tabIndex: -1
        }, index);
      })]
    })]
  });
}

exports.BarGroup = BarGroup;
