'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var polarisVizCore = require('@shopify/polaris-viz-core');
var d3Shape = require('d3-shape');
var useIndexForLabels = require('../../hooks/useIndexForLabels.js');
var index = require('../ChartElements/index.js');
var useFormattedLabels = require('../../hooks/useFormattedLabels.js');
var getVerticalBarChartTooltipPosition = require('../../utilities/getVerticalBarChartTooltipPosition.js');
var constants = require('../../constants.js');
var useVerticalBarChart = require('./hooks/useVerticalBarChart.js');
var jsxRuntime = require('react/jsx-runtime');
var useColorVisionEvents = require('../../hooks/ColorVisionA11y/useColorVisionEvents.js');
var useLegend = require('../LegendContainer/hooks/useLegend.js');
var getStackedValues = require('../../utilities/getStackedValues.js');
var useReducedLabelIndexes = require('../../hooks/useReducedLabelIndexes.js');
var getStackedMinMax = require('../../utilities/getStackedMinMax.js');
var useBarChartTooltipContent = require('../../hooks/useBarChartTooltipContent.js');
var checkAvailableAnnotations = require('../Annotations/utilities/checkAvailableAnnotations.js');
var XAxis = require('../XAxis/XAxis.js');
var GradientDefs = require('../shared/GradientDefs/GradientDefs.js');
var HorizontalGridLines = require('../HorizontalGridLines/HorizontalGridLines.js');
var YAxis = require('../YAxis/YAxis.js');
var VerticalBarGroup = require('./components/VerticalBarGroup/VerticalBarGroup.js');
var Annotations = require('../Annotations/Annotations.js');
var YAxisAnnotations = require('../Annotations/YAxisAnnotations.js');
var TooltipWrapper = require('../TooltipWrapper/TooltipWrapper.js');
var LegendContainer = require('../LegendContainer/LegendContainer.js');
var constants$1 = require('../TooltipWrapper/constants.js');
var types = require('../TooltipWrapper/types.js');

function Chart({
  annotationsLookupTable = {},
  data,
  dimensions,
  emptyStateText,
  renderLegendContent,
  renderTooltipContent,
  showLegend,
  type,
  xAxisOptions,
  yAxisOptions,
  renderHiddenLegendLabel,
  seriesNameFormatter
}) {
  useColorVisionEvents.useColorVisionEvents({
    enabled: data.length > 1,
    dimensions
  });
  const selectedTheme = polarisVizCore.useTheme();
  const {
    characterWidths
  } = polarisVizCore.useChartContext();
  const [svgRef, setSvgRef] = React.useState(null);
  const id = React.useMemo(() => polarisVizCore.uniqueId('VerticalBarChart'), []);
  const [xAxisHeight, setXAxisHeight] = React.useState(polarisVizCore.LINE_HEIGHT);
  const [annotationsHeight, setAnnotationsHeight] = React.useState(0);
  const {
    legend,
    setLegendDimensions,
    height,
    width
  } = useLegend.useLegend({
    data: [{
      shape: 'Bar',
      series: data
    }],
    dimensions,
    showLegend,
    seriesNameFormatter
  });
  const emptyState = data.length === 0;
  const indexForLabels = useIndexForLabels.useIndexForLabels(data);
  const {
    formattedLabels,
    unformattedLabels
  } = useFormattedLabels.useFormattedLabels({
    data: [data[indexForLabels]],
    labelFormatter: xAxisOptions.labelFormatter
  });
  const isStacked = type === 'stacked';
  const stackedValues = isStacked ? getStackedValues.getStackedValues({
    series: data,
    labels: formattedLabels,
    order: d3Shape.stackOrderNone,
    offset: d3Shape.stackOffsetDiverging
  }) : null;
  const reducedLabelIndexes = useReducedLabelIndexes.useReducedLabelIndexes({
    dataLength: data[0] ? data[0].data.length : 0
  });
  const {
    min,
    max
  } = getStackedMinMax.getStackedMinMax({
    stackedValues,
    data,
    integersOnly: yAxisOptions.integersOnly
  });
  let yScaleMax;

  if (yAxisOptions.maxYOverride === null) {
    yScaleMax = max;
  } else {
    const allValuesAreZero = data.every(series => series.data.every(point => point.value === 0));
    yScaleMax = allValuesAreZero ? 0 : max;
  }

  const yScaleOptions = {
    formatYAxisLabel: yAxisOptions.labelFormatter,
    integersOnly: yAxisOptions.integersOnly,
    maxYOverride: yAxisOptions.maxYOverride,
    max: yScaleMax,
    min
  };
  const {
    ticks: initialTicks
  } = polarisVizCore.useYScale({ ...yScaleOptions,
    drawableHeight: height,
    verticalOverflow: selectedTheme.grid.verticalOverflow
  });
  const yAxisLabelWidth = React.useMemo(() => {
    const longest = Math.max(...initialTicks.map(({
      formattedValue
    }) => polarisVizCore.estimateStringWidth(formattedValue, characterWidths)));
    return longest;
  }, [characterWidths, initialTicks]);
  const {
    drawableWidth,
    drawableHeight,
    chartXPosition,
    chartYPosition,
    xAxisBounds,
    yAxisBounds
  } = polarisVizCore.useChartPositions({
    annotationsHeight,
    height,
    width,
    xAxisHeight,
    yAxisWidth: yAxisLabelWidth
  });
  const annotationsDrawableHeight = chartYPosition + drawableHeight + constants.ANNOTATIONS_LABELS_OFFSET;
  const chartBounds = {
    width,
    height,
    x: chartXPosition,
    y: chartYPosition
  };
  const hideXAxis = xAxisOptions.hide || selectedTheme.xAxis.hide;
  const {
    sortedData,
    areAllNegative,
    xScale,
    gapWidth
  } = useVerticalBarChart.useVerticalBarChart({
    data,
    drawableWidth,
    labels: formattedLabels
  });
  const {
    ticks,
    yScale
  } = polarisVizCore.useYScale({ ...yScaleOptions,
    drawableHeight,
    verticalOverflow: selectedTheme.grid.verticalOverflow
  });
  const barColors = data.map(({
    color
  }) => color);
  const getTooltipMarkup = useBarChartTooltipContent.useBarChartTooltipContent({
    renderTooltipContent,
    data,
    seriesColors: barColors,
    seriesNameFormatter
  });
  const {
    hasXAxisAnnotations,
    hasYAxisAnnotations
  } = checkAvailableAnnotations.checkAvailableAnnotations(annotationsLookupTable);
  const xAxisLabelHalf = xScale.bandwidth() / 2;
  return /*#__PURE__*/jsxRuntime.jsxs(index.ChartElements.Div, {
    height: height,
    width: width,
    children: [/*#__PURE__*/jsxRuntime.jsxs(index.ChartElements.Svg, {
      height: height,
      width: width,
      emptyStateText: emptyStateText,
      emptyState: emptyState,
      setRef: setSvgRef,
      children: [hideXAxis ? null : /*#__PURE__*/jsxRuntime.jsx(XAxis.XAxis, {
        allowLineWrap: xAxisOptions.allowLineWrap,
        labels: formattedLabels,
        labelWidth: xScale.bandwidth(),
        onHeightChange: setXAxisHeight,
        reducedLabelIndexes: reducedLabelIndexes,
        x: xAxisBounds.x,
        xScale: xScale,
        y: xAxisBounds.y
      }), /*#__PURE__*/jsxRuntime.jsx(GradientDefs.GradientDefs, {
        direction: "vertical",
        gradientUnits: isStacked ? 'objectBoundingBox' : 'userSpaceOnUse',
        id: id,
        seriesColors: barColors,
        size: isStacked ? '100%' : `${width}px`
      }), selectedTheme.grid.showHorizontalLines ? /*#__PURE__*/jsxRuntime.jsx(HorizontalGridLines.HorizontalGridLines, {
        ticks: ticks,
        transform: {
          x: selectedTheme.grid.horizontalOverflow ? 0 : chartXPosition,
          y: chartYPosition
        },
        width: selectedTheme.grid.horizontalOverflow ? width : drawableWidth
      }) : null, /*#__PURE__*/jsxRuntime.jsx(YAxis.YAxis, {
        ticks: ticks,
        textAlign: "right",
        width: yAxisLabelWidth,
        x: yAxisBounds.x,
        y: yAxisBounds.y
      }), /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition},${chartYPosition})`,
        children: /*#__PURE__*/jsxRuntime.jsx(VerticalBarGroup.VerticalBarGroup, {
          colors: barColors,
          data: data,
          drawableHeight: drawableHeight,
          gapWidth: gapWidth,
          id: id,
          labels: formattedLabels,
          sortedData: sortedData,
          stackedValues: stackedValues,
          xScale: xScale,
          yAxisOptions: yAxisOptions,
          yScale: yScale,
          areAllNegative: areAllNegative
        })
      }), hasXAxisAnnotations && /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition + xAxisLabelHalf},0)`,
        tabIndex: -1,
        children: /*#__PURE__*/jsxRuntime.jsx(Annotations.Annotations, {
          annotationsLookupTable: annotationsLookupTable,
          axisLabelWidth: xScale.bandwidth(),
          drawableHeight: annotationsDrawableHeight,
          drawableWidth: drawableWidth,
          labels: unformattedLabels,
          onHeightChange: setAnnotationsHeight,
          xScale: xScale
        })
      }), hasYAxisAnnotations && /*#__PURE__*/jsxRuntime.jsx("g", {
        transform: `translate(${chartXPosition},${chartYPosition})`,
        tabIndex: -1,
        children: /*#__PURE__*/jsxRuntime.jsx(YAxisAnnotations.YAxisAnnotations, {
          annotationsLookupTable: annotationsLookupTable,
          drawableHeight: annotationsDrawableHeight,
          drawableWidth: drawableWidth,
          ticks: ticks,
          yScale: yScale
        })
      })]
    }), sortedData.length > 0 && /*#__PURE__*/jsxRuntime.jsx(TooltipWrapper.TooltipWrapper, {
      bandwidth: xScale.bandwidth(),
      chartBounds: chartBounds,
      focusElementDataType: polarisVizCore.DataType.BarGroup,
      getMarkup: getTooltipMarkup,
      getPosition: getTooltipPosition,
      margin: { ...polarisVizCore.ChartMargin,
        Top: chartYPosition
      },
      parentRef: svgRef,
      chartDimensions: dimensions,
      usePortal: true
    }), showLegend && /*#__PURE__*/jsxRuntime.jsx(LegendContainer.LegendContainer, {
      colorVisionType: polarisVizCore.COLOR_VISION_SINGLE_ITEM,
      data: legend,
      onDimensionChange: setLegendDimensions,
      renderLegendContent: renderLegendContent,
      enableHideOverflow: true,
      dimensions: dimensions,
      renderHiddenLegendLabel: renderHiddenLegendLabel
    })]
  });

  function formatPositionForTooltip(index) {
    var _xScale, _dimensions$x, _dimensions$y;

    if (index == null) {
      return constants$1.TOOLTIP_POSITION_DEFAULT_RETURN;
    }

    const xPosition = (_xScale = xScale(`${index}`)) !== null && _xScale !== void 0 ? _xScale : 0;
    const sortedDataPos = sortedData[index].map(num => Math.abs(num !== null && num !== void 0 ? num : 0));
    const highestValuePos = type === 'stacked' ? sortedData[index].reduce(sumPositiveData, 0) : Math.max(...sortedDataPos);
    const x = xPosition + chartXPosition;
    const y = yScale(highestValuePos) + chartYPosition;
    return {
      x: x + ((_dimensions$x = dimensions === null || dimensions === void 0 ? void 0 : dimensions.x) !== null && _dimensions$x !== void 0 ? _dimensions$x : 0),
      y: Math.abs(y) + ((_dimensions$y = dimensions === null || dimensions === void 0 ? void 0 : dimensions.y) !== null && _dimensions$y !== void 0 ? _dimensions$y : 0),
      position: {
        horizontal: types.TooltipHorizontalOffset.Center,
        vertical: areAllNegative ? types.TooltipVerticalOffset.Below : types.TooltipVerticalOffset.Above
      },
      activeIndex: index
    };
  }

  function getTooltipPosition({
    event,
    index,
    eventType
  }) {
    return getVerticalBarChartTooltipPosition.getVerticalBarChartTooltipPosition({
      tooltipPosition: {
        event,
        index,
        eventType
      },
      chartXPosition,
      formatPositionForTooltip,
      maxIndex: sortedData.length - 1,
      step: xScale.step(),
      yMin: polarisVizCore.ChartMargin.Top,
      yMax: drawableHeight + Number(polarisVizCore.ChartMargin.Bottom) + xAxisHeight
    });
  }
}

function sumPositiveData(prevValue, currValue) {
  return currValue < 0 ? prevValue : prevValue + currValue;
}

exports.Chart = Chart;
