'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var reactDom = require('react-dom');
var useRootContainer = require('../../hooks/useRootContainer.js');
var shouldBlockTooltipEvents = require('./utilities/shouldBlockTooltipEvents.js');
var constants = require('./constants.js');
var TooltipAnimatedContainer = require('./components/TooltipAnimatedContainer.js');
var jsxRuntime = require('react/jsx-runtime');
var SwallowErrors = require('../SwallowErrors/SwallowErrors.js');

const TOOLTIP_ID = 'polaris_viz_tooltip_root';

function TooltipWrapperRaw(props) {
  const {
    alwaysUpdatePosition = false,
    bandwidth = 0,
    chartBounds,
    focusElementDataType,
    getAlteredPosition,
    getPosition,
    id,
    onIndexChange,
    parentRef,
    chartDimensions
  } = props;
  const [position, setPosition] = React.useState({
    x: 0,
    y: 0,
    activeIndex: -1,
    position: constants.DEFAULT_TOOLTIP_POSITION
  });
  const activeIndexRef = React.useRef(null);
  const focusElements = React.useMemo(() => {
    return parentRef === null || parentRef === void 0 ? void 0 : parentRef.querySelectorAll(`[data-type="${focusElementDataType}"][aria-hidden="false"]`);
  }, [focusElementDataType, parentRef]);
  React.useEffect(() => {
    activeIndexRef.current = position.activeIndex;
  }, [position.activeIndex]);
  const onMouseMove = React.useCallback(event => {
    const newPosition = getPosition({
      event,
      eventType: 'mouse'
    });

    if (alwaysUpdatePosition && (newPosition.x < chartBounds.x || newPosition.y < chartBounds.y)) {
      return;
    }

    if (!alwaysUpdatePosition && activeIndexRef.current === newPosition.activeIndex) {
      return;
    }

    if (shouldBlockTooltipEvents.shouldBlockTooltipEvents(event)) {
      return;
    }

    setPosition(newPosition);
    onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(newPosition.activeIndex);
  }, [alwaysUpdatePosition, chartBounds, getPosition, onIndexChange]);
  const onMouseLeave = React.useCallback(() => {
    onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(null);
    setPosition(prevState => {
      return { ...prevState,
        activeIndex: -1
      };
    });
  }, [onIndexChange]);
  const onFocus = React.useCallback(event => {
    const target = event.currentTarget;

    if (!target) {
      return;
    }

    const index = Number(target.dataset.index);
    const newPosition = getPosition({
      index,
      eventType: 'focus'
    });
    setPosition(newPosition);
    onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(newPosition.activeIndex);
  }, [getPosition, onIndexChange]);
  const onFocusIn = React.useCallback(() => {
    if (!(parentRef !== null && parentRef !== void 0 && parentRef.contains(document.activeElement))) {
      onMouseLeave();
    }
  }, [parentRef, onMouseLeave]);
  const setFocusListeners = React.useCallback(attach => {
    if (!focusElements) {
      return;
    }

    focusElements.forEach(el => {
      if (attach) {
        el.addEventListener('focus', onFocus);
      } else {
        el.removeEventListener('focus', onFocus);
      }
    });
  }, [focusElements, onFocus]);
  React.useEffect(() => {
    if (!parentRef) {
      return;
    }

    parentRef.addEventListener('mousemove', onMouseMove);
    parentRef.addEventListener('mouseleave', onMouseLeave);
    parentRef.addEventListener('touchmove', onMouseMove);
    parentRef.addEventListener('touchend', onMouseLeave);
    setFocusListeners(true);
    return () => {
      parentRef.removeEventListener('mousemove', onMouseMove);
      parentRef.removeEventListener('mouseleave', onMouseLeave);
      parentRef.removeEventListener('touchmove', onMouseMove);
      parentRef.removeEventListener('touchend', onMouseLeave);
      setFocusListeners(false);
    };
  }, [parentRef, onMouseMove, onMouseLeave, onFocus, setFocusListeners]);
  React.useEffect(() => {
    document.addEventListener('focusin', onFocusIn);
    return () => {
      document.removeEventListener('focusin', onFocusIn);
    };
  }, [parentRef, onFocusIn]);

  if (position.activeIndex == null || position.activeIndex < 0) {
    return null;
  }

  return /*#__PURE__*/jsxRuntime.jsx(TooltipAnimatedContainer.TooltipAnimatedContainer, {
    activePointIndex: position.activeIndex,
    bandwidth: bandwidth,
    chartBounds: chartBounds,
    currentX: position.x,
    currentY: position.y,
    id: id,
    getAlteredPosition: getAlteredPosition,
    margin: props.margin,
    position: position.position,
    chartDimensions: chartDimensions,
    children: props.getMarkup(position.activeIndex)
  });
}

function TooltipWrapper({
  usePortal = false,
  ...props
}) {
  if (usePortal) {
    return /*#__PURE__*/jsxRuntime.jsx(TooltipWithPortal, { ...props
    });
  }

  return /*#__PURE__*/jsxRuntime.jsx(TooltipWithErrors, { ...props
  });
}

function TooltipWithErrors(props) {
  return /*#__PURE__*/jsxRuntime.jsx(SwallowErrors.SwallowErrors, {
    children: /*#__PURE__*/jsxRuntime.jsx(TooltipWrapperRaw, { ...props
    })
  });
}

function TooltipWithPortal(props) {
  const container = useRootContainer.useRootContainer(TOOLTIP_ID);
  return /*#__PURE__*/reactDom.createPortal( /*#__PURE__*/jsxRuntime.jsx(TooltipWithErrors, { ...props
  }), container);
}

exports.TooltipWrapper = TooltipWrapper;
