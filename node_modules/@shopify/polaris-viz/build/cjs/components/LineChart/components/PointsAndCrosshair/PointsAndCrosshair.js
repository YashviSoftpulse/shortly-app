'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var polarisVizCore = require('@shopify/polaris-viz-core');
var d3Shape = require('d3-shape');
var constants = require('../../../../constants.js');
var jsxRuntime = require('react/jsx-runtime');
var useLinearChartAnimations = require('../../../../hooks/useLinearChartAnimations.js');
var Crosshair = require('../../../Crosshair/Crosshair.js');
var Points = require('../Points/Points.js');

function PointsAndCrosshair({
  activeIndex,
  data,
  drawableHeight,
  emptyState,
  hiddenIndexes = [],
  longestSeriesIndex,
  theme,
  tooltipId,
  xScale,
  yScale
}) {
  const selectedTheme = polarisVizCore.useTheme(theme);
  const {
    shouldAnimate,
    isPerformanceImpacted
  } = polarisVizCore.useChartContext();
  const gradientId = React.useRef(polarisVizCore.uniqueId('lineChartGradient'));
  const lineGenerator = React.useMemo(() => {
    const generator = d3Shape.line().x((_, index) => xScale == null ? 0 : xScale(index)).y(({
      value
    }) => yScale(value !== null && value !== void 0 ? value : 0));

    if (selectedTheme.line.hasSpline) {
      generator.curve(polarisVizCore.curveStepRounded);
    }

    return generator;
  }, [selectedTheme.line.hasSpline, xScale, yScale]);
  const {
    animatedCoordinates
  } = useLinearChartAnimations.useLinearChartAnimations({
    data,
    lineGenerator,
    activeIndex
  });

  const getXPosition = ({
    isCrosshair
  } = {
    isCrosshair: false
  }) => {
    if (xScale == null) {
      return 0;
    }

    const offset = isCrosshair ? selectedTheme.crossHair.width / 2 : 0;

    if (animatedCoordinates != null && animatedCoordinates[longestSeriesIndex] != null && shouldAnimate) {
      return animatedCoordinates[longestSeriesIndex].to(coord => coord.x - offset);
    }

    return xScale(activeIndex == null ? 0 : activeIndex) - offset;
  };

  return /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
    children: [emptyState ? null : /*#__PURE__*/jsxRuntime.jsx(Crosshair.Crosshair, {
      height: drawableHeight,
      id: `${tooltipId}-${constants.CROSSHAIR_ID}`,
      opacity: activeIndex == null ? 0 : 1,
      theme: theme,
      x: getXPosition({
        isCrosshair: true
      })
    }), isPerformanceImpacted ? null : /*#__PURE__*/jsxRuntime.jsx(Points.Points, {
      activeIndex: emptyState ? null : activeIndex,
      animatedCoordinates: animatedCoordinates,
      data: data,
      getXPosition: getXPosition,
      gradientId: gradientId.current,
      hiddenIndexes: hiddenIndexes,
      longestSeriesIndex: longestSeriesIndex,
      tooltipId: tooltipId,
      xScale: xScale,
      yScale: yScale
    })]
  });
}

exports.PointsAndCrosshair = PointsAndCrosshair;
