'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var polarisVizCore = require('@shopify/polaris-viz-core');
var constants = require('../constants.js');

function useYAxisAnnotationPositions({
  annotations,
  axis,
  drawableWidth,
  ticks,
  yScale
}) {
  const {
    characterWidths
  } = polarisVizCore.useChartContext();
  const textWidths = React.useMemo(() => {
    return annotations.map(annotation => {
      return polarisVizCore.estimateStringWidth(annotation.label, characterWidths);
    });
  }, [annotations, characterWidths]);
  const {
    positions
  } = React.useMemo(() => {
    let positions = annotations.map((annotation, dataIndex) => {
      var _yScale;

      const rawY = (_yScale = yScale(Number(annotation.startKey))) !== null && _yScale !== void 0 ? _yScale : 0;
      const textWidth = textWidths[dataIndex];
      const width = polarisVizCore.clamp({
        amount: textWidth + constants.PILL_PADDING * 2,
        min: textWidth + constants.PILL_PADDING * 2,
        max: drawableWidth
      });
      const y = polarisVizCore.clamp({
        amount: rawY - constants.PILL_HEIGHT / 2,
        min: 0,
        max: Infinity
      });
      const x = axis === 'y2' ? 0 : drawableWidth - width;
      const lineWidth = axis === 'y2' ? drawableWidth : drawableWidth - (drawableWidth - x);
      return {
        index: dataIndex,
        line: {
          x: 0,
          y: rawY,
          width: lineWidth
        },
        showYAxisLabel: true,
        row: 1,
        width,
        x,
        y
      };
    });
    positions = positions.sort((one, two) => one.y - two.y);
    ticks.forEach(({
      yOffset
    }) => {
      positions.forEach(current => {
        const top = current.line.y - polarisVizCore.LINE_HEIGHT / 2;
        const bottom = top + polarisVizCore.LINE_HEIGHT;

        if (yOffset > top && yOffset < bottom) {
          current.showYAxisLabel = false;
        }
      });
    });

    function checkForSpace(totalRows) {
      let checkAgain = false;
      [...Array.from({
        length: totalRows
      })].forEach((_, rowIndex) => {
        const currentRow = rowIndex + 1;
        positions.filter(({
          row
        }) => row === currentRow).forEach((current, index, filtered) => {
          const nextRow = currentRow + 1;
          const next = filtered[index + 1];

          if (next == null) {
            return;
          }

          if (current.line.y + constants.ANNOTATION_Y_AXIS_LABEL_HEIGHT > next.line.y) {
            next.showYAxisLabel = false;
          }

          const top = current.y;
          const bottom = current.y + constants.PILL_HEIGHT;

          if (current.row === next.row && next.y > top && next.y < bottom) {
            next.row = nextRow;
            checkAgain = true;
          }
        });
      });

      if (checkAgain) {
        checkForSpace(totalRows + 1);
      }
    }

    checkForSpace(1);
    positions.forEach(current => {
      const row = current.row - 1;

      if (axis === 'y2') {
        current.x += (current.width + constants.PILL_ROW_GAP) * row;
      } else {
        current.x -= (current.width + constants.PILL_ROW_GAP) * row;
      }
    });
    return {
      positions
    };
  }, [annotations, ticks, textWidths, yScale, drawableWidth, axis]);
  return {
    positions
  };
}

exports.useYAxisAnnotationPositions = useYAxisAnnotationPositions;
