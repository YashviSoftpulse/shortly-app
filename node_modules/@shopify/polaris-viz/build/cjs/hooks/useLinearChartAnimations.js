'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var web = require('@react-spring/web');
var polarisVizCore = require('@shopify/polaris-viz-core');
var getPathLength = require('../utilities/getPathLength.js');
var getPointAtLength = require('../utilities/getPointAtLength.js');

const SPRING_CONFIG = {
  friction: 5,
  clamp: true,
  mass: 1,
  tension: 190
};
function useLinearChartAnimations({
  activeIndex,
  lineGenerator,
  data
}) {
  const {
    shouldAnimate
  } = polarisVizCore.useChartContext();
  const currentIndex = activeIndex == null ? 0 : activeIndex;
  const immediate = !shouldAnimate || data.length === 0 || activeIndex == null; // Create off screen paths used for sub path and total path length calculations

  const createOffScreenPath = React.useCallback(data => {
    const offscreenPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    offscreenPath.setAttribute('d', lineGenerator(data) || '');
    return offscreenPath;
  }, [lineGenerator]); // Get total lengths of paths for all data

  const totalPaths = React.useMemo(() => {
    if (immediate) return null;
    return data.map(({
      data
    }) => {
      const offscreenPath = createOffScreenPath(data);
      return {
        element: offscreenPath,
        length: getPathLength.getPathLength(offscreenPath)
      };
    });
  }, [immediate, createOffScreenPath, data]); // Get length of subpaths at current index for all data

  const subPaths = React.useMemo(() => {
    if (immediate) return null;
    return data.map(({
      data
    }) => {
      const path = createOffScreenPath(data.slice(0, currentIndex + 1));
      return {
        element: path,
        length: getPathLength.getPathLength(path)
      };
    });
  }, [immediate, createOffScreenPath, currentIndex, data]); // Get percentage of subpath compared to total length

  const getPercentage = React.useCallback((subpathLength, totalLength) => {
    if (totalLength === 0) {
      return 0;
    }

    return subpathLength / totalLength * 100;
  }, []); // Calculate percentage for subpath compared to total length of all data

  const percentages = React.useMemo(() => {
    if (immediate || !totalPaths || !subPaths) return null;
    return data.map((_, index) => {
      const totalLength = totalPaths[index].length;
      const subPath = subPaths[index];
      return getPercentage(subPath.length, totalLength);
    });
  }, [immediate, totalPaths, subPaths, data, getPercentage]); // Using the percentage, get the length to calculate the coordinates at the current index

  const getCoordinatesFromPercentage = React.useCallback((percent, path, totalLength) => {
    if (path == null || totalLength == null || totalLength === 0) {
      return {
        x: 0,
        y: 0
      };
    }

    const length = percent * totalLength / 100;
    return getPointAtLength.getPointAtLength(path, length);
  }, []); // Create a spring with the same config for each series

  const animatedPercentages = web.useSprings(percentages == null ? 0 : percentages.length, percentages == null ? [] : percentages.map(percentage => ({
    percentage,
    config: SPRING_CONFIG,
    default: {
      immediate
    }
  }))); // Return animated coordinates by interpolating the percentage

  return {
    animatedCoordinates: immediate || totalPaths == null ? null : animatedPercentages.map(({
      percentage
    }, index) => {
      return percentage.to(percent => {
        const totalLength = totalPaths[index].length;
        const path = totalPaths[index].element;
        return getCoordinatesFromPercentage(percent, path, totalLength);
      });
    })
  };
}

exports.SPRING_CONFIG = SPRING_CONFIG;
exports.useLinearChartAnimations = useLinearChartAnimations;
