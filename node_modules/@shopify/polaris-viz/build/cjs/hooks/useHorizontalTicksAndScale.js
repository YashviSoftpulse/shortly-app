'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var d3Array = require('d3-array');
var d3Scale = require('d3-scale');
var React = require('react');

function useHorizontalTicksAndScale({
  maxWidth,
  allNumbers,
  labelFormatter,
  isStacked,
  stackedMin,
  stackedMax
}) {
  const xScale = React.useMemo(() => {
    const areAllZero = !allNumbers.some(num => num != null && num !== 0);
    const domainValues = [0, ...allNumbers];

    if (areAllZero) {
      domainValues.push(1);
    }

    return d3Scale.scaleLinear().range([0, maxWidth]).domain(d3Array.extent(domainValues, num => num)).nice();
  }, [maxWidth, allNumbers]);
  const ticks = React.useMemo(() => {
    return xScale.ticks();
  }, [xScale]);
  const xScaleStacked = React.useMemo(() => {
    if (!isStacked) {
      return null;
    }

    const xScale = d3Scale.scaleLinear().range([0, maxWidth]).domain([stackedMin, stackedMax]).nice();
    return xScale;
  }, [isStacked, maxWidth, stackedMin, stackedMax]);
  const ticksStacked = React.useMemo(() => {
    if (!isStacked || !xScaleStacked) {
      return [];
    }

    return xScaleStacked.ticks();
  }, [isStacked, xScaleStacked]);
  const finalTicks = isStacked ? ticksStacked : ticks;
  return {
    ticks: finalTicks,
    xScale: isStacked ? xScaleStacked : xScale,
    ticksFormatted: finalTicks.map(tick => `${labelFormatter(tick)}`)
  };
}

exports.useHorizontalTicksAndScale = useHorizontalTicksAndScale;
