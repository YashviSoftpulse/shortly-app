import { useState, useMemo, Fragment } from 'react';
import { area, line } from 'd3-shape';
import { usePrevious, COLOR_VISION_SINGLE_ITEM, useTheme, uniqueId, curveStepRounded, LINE_ANIMATION_DURATION_STEP, LINE_ANIMATION_FAST_COUNT, LINE_ANIMATION_FAST_DURATION, LINE_ANIMATION_SLOW_DURATION } from '@shopify/polaris-viz-core';
import { jsx } from 'react/jsx-runtime';
import { useWatchColorVisionEvents } from '../../../../hooks/ColorVisionA11y/useWatchColorVisionEvents.js';
import { AnimatedArea } from '../Area/AnimatedArea.js';
import { Area } from '../Area/Area.js';

function StackedAreas({
  stackedValues,
  xScale,
  yScale,
  colors,
  theme,
  zeroLineValues
}) {
  const [activeLineIndex, setActiveLineIndex] = useState(-1);
  const previousStackedValues = usePrevious(stackedValues);
  useWatchColorVisionEvents({
    type: COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => {
      setActiveLineIndex(detail.index);
    }
  });
  const selectedTheme = useTheme(theme);
  const id = useMemo(() => uniqueId('stackedAreas'), []);
  const areaGenerator = area().defined(([firstPoint, lastPoint]) => !isNaN(firstPoint) && !isNaN(lastPoint)).x((_, index) => xScale(index)).y0(([firstPoint]) => yScale(firstPoint)).y1(([, lastPoint]) => yScale(lastPoint));
  const lineGenerator = line().defined(([firstPoint, lastPoint]) => !isNaN(firstPoint) && !isNaN(lastPoint)).x((_, index) => xScale(index)).y(([, lastPoint]) => yScale(lastPoint));

  if (selectedTheme.line.hasSpline) {
    areaGenerator.curve(curveStepRounded);
    lineGenerator.curve(curveStepRounded);
  }

  const duration = useMemo(() => {
    const count = stackedValues.length;
    const duration = count > LINE_ANIMATION_FAST_COUNT ? LINE_ANIMATION_FAST_DURATION : LINE_ANIMATION_SLOW_DURATION - count * LINE_ANIMATION_DURATION_STEP;
    return Math.round(duration / LINE_ANIMATION_DURATION_STEP) * LINE_ANIMATION_DURATION_STEP;
  }, [stackedValues.length]);
  return /*#__PURE__*/jsx(Fragment, {
    children: stackedValues.map((data, index) => {
      const dataIsValidForAnimation = !previousStackedValues || data.length === previousStackedValues[index].length;
      const AreaComponent = dataIsValidForAnimation ? AnimatedArea : Area;
      return /*#__PURE__*/jsx(AreaComponent, {
        activeLineIndex: activeLineIndex,
        animationIndex: index,
        areaGenerator: areaGenerator,
        colors: colors,
        data: data,
        zeroLineValues: zeroLineValues[index],
        duration: duration,
        id: id,
        index: index,
        lineGenerator: lineGenerator,
        selectedTheme: selectedTheme
      }, `${id}-${index}`);
    })
  });
}

export { StackedAreas };
