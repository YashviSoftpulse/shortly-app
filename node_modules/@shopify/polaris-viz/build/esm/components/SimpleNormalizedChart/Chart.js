import { useState } from 'react';
import { sum } from 'd3-array';
import { scaleLinear } from 'd3-scale';
import { useTheme, COLOR_VISION_SINGLE_ITEM, getColorVisionStylesForActiveIndex, getColorVisionEventAttrs } from '@shopify/polaris-viz-core';
import { useThemeSeriesColors } from '../../hooks/useThemeSeriesColors.js';
import { WARN_FOR_DEVELOPMENT } from '../../constants.js';
import styles from './SimpleNormalizedChart.scss.js';
import { jsxs, jsx } from 'react/jsx-runtime';
import { useColorVisionEvents } from '../../hooks/ColorVisionA11y/useColorVisionEvents.js';
import { useWatchColorVisionEvents } from '../../hooks/ColorVisionA11y/useWatchColorVisionEvents.js';
import { classNames } from '../../utilities/classnames.js';
import { BarSegment } from './components/BarSegment/BarSegment.js';
import { BarLabel } from './components/BarLabel/BarLabel.js';

function Chart({
  comparisonMetrics = [],
  data,
  labelFormatter,
  legendPosition = 'top-left',
  seriesNameFormatter,
  direction = 'horizontal',
  size = 'small',
  showLegend = true,
  renderLegendContent
}) {
  const flattenedData = data.map(({
    data
  }) => data).flat();
  useColorVisionEvents();
  const selectedTheme = useTheme();
  const colors = useThemeSeriesColors(data, selectedTheme);
  const containsNegatives = flattenedData.some(({
    value
  }) => value !== null && value < 0);
  const [activeIndex, setActiveIndex] = useState(-1);
  useWatchColorVisionEvents({
    type: COLOR_VISION_SINGLE_ITEM,
    onIndexChange: ({
      detail
    }) => setActiveIndex(detail.index)
  });

  if (WARN_FOR_DEVELOPMENT && containsNegatives) {
    // eslint-disable-next-line no-console
    console.warn('This component is not built to handle negatives. Consider using a different component.');
  }

  if (WARN_FOR_DEVELOPMENT && flattenedData.length > 4) {
    throw new Error('This component displays a max of 4 data items. Please modify your data before passing it into this component.');
  }

  const slicedData = flattenedData.slice(0, 4);
  const totalValue = sum(slicedData, ({
    value
  }) => value);
  const xScale = scaleLinear().range([0, 100]).domain([0, totalValue]);
  const isVertical = direction === 'vertical';
  const bars = isVertical ? slicedData.reverse() : slicedData;
  const isEmptyValues = slicedData.every(({
    value
  }) => !value);
  const isRightLabel = legendPosition.includes('right');
  const isBottomLabel = legendPosition.includes('bottom');
  const isVerticalAndRightLabel = isVertical && isRightLabel;
  const isVerticalAndBottomLabel = isVertical && isBottomLabel;
  const isHorizontalAndRightLabel = !isVertical && isRightLabel;
  const isHorizontalAndBottomLabel = !isVertical && isBottomLabel;

  const legendMarkup = () => {
    if (!showLegend) {
      return null;
    }

    if (renderLegendContent) {
      const colorVisionInteractionMethods = {
        getColorVisionStyles: index => getColorVisionStylesForActiveIndex({
          activeIndex,
          index
        }),
        getColorVisionEventAttrs: index => getColorVisionEventAttrs({
          type: COLOR_VISION_SINGLE_ITEM,
          index
        })
      };
      return /*#__PURE__*/jsx("div", {
        className: classNames(isVertical ? styles.VerticalLabelContainer : styles.HorizontalLabelContainer, (isVerticalAndBottomLabel || isHorizontalAndRightLabel) && styles.LabelContainerEndJustify),
        children: renderLegendContent(colorVisionInteractionMethods)
      });
    }

    return /*#__PURE__*/jsx("ul", {
      className: classNames(...(isVertical ? [styles.VerticalLabelContainer] : [styles.HorizontalLabelContainer, styles.HorizontalLabelContainerGrid]), (isVerticalAndBottomLabel || isHorizontalAndRightLabel) && styles.LabelContainerEndJustify),
      children: slicedData.map(({
        key,
        value
      }, index) => {
        var _data$index$name$toSt, _data$index$name;

        if (value == null) {
          return null;
        }

        const comparisonMetric = comparisonMetrics.find(({
          dataIndex
        }) => index === dataIndex);
        const formattedValue = labelFormatter(value);
        const formattedName = seriesNameFormatter((_data$index$name$toSt = (_data$index$name = data[index].name) === null || _data$index$name === void 0 ? void 0 : _data$index$name.toString()) !== null && _data$index$name$toSt !== void 0 ? _data$index$name$toSt : '');
        return /*#__PURE__*/jsx(BarLabel, {
          activeIndex: activeIndex,
          index: index,
          label: formattedName,
          value: formattedValue,
          color: colors[index],
          comparisonMetric: comparisonMetric,
          direction: direction,
          legendPosition: legendPosition
        }, `${key}-${formattedValue}-${index}`);
      })
    });
  };

  return /*#__PURE__*/jsxs("div", {
    className: classNames(styles.Container, isVertical ? styles.VerticalContainer : styles.HorizontalContainer, isVerticalAndRightLabel && styles.VerticalContainerRightLabel, isHorizontalAndBottomLabel && styles.HorizontalContainerBottomLabel),
    children: [legendMarkup(), /*#__PURE__*/jsx("div", {
      className: classNames(styles.BarContainer, isVertical ? styles.VerticalBarContainer : styles.HorizontalBarContainer),
      children: isEmptyValues ? /*#__PURE__*/jsx(BarSegment, {
        activeIndex: -1,
        index: -1,
        direction: direction,
        size: size,
        scale: 100,
        color: selectedTheme.seriesColors.empty,
        roundedCorners: selectedTheme.bar.borderRadius
      }, "empty-bar") : bars.map(({
        value,
        key
      }, index) => {
        if (value == null || value === 0) {
          return null;
        }

        const colorIndex = isVertical ? bars.length - 1 - index : index;
        return /*#__PURE__*/jsx(BarSegment, {
          activeIndex: activeIndex,
          index: colorIndex,
          direction: direction,
          size: size,
          scale: xScale(value),
          color: colors[colorIndex],
          roundedCorners: selectedTheme.bar.borderRadius
        }, `${key}-${index}`);
      })
    })]
  });
}

export { Chart };
