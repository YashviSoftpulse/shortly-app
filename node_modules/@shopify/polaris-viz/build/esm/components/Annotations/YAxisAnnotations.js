import { useState, useMemo, Fragment } from 'react';
import { isValueWithinDomain, Y_AXIS_CHART_SPACING } from '@shopify/polaris-viz-core';
import { useSVGBlurEvent } from '../../hooks/useSVGBlurEvent.js';
import { useYAxisAnnotationPositions } from './hooks/useYAxisAnnotationPositions.js';
import styles from './Annotations.scss.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import { AnnotationYAxisLabel } from './components/AnnotationYAxisLabel/AnnotationYAxisLabel.js';
import { AnnotationLine } from './components/AnnotationLine/AnnotationLine.js';
import { AnnotationLabel } from './components/AnnotationLabel/AnnotationLabel.js';
import { AnnotationContent } from './components/AnnotationContent/AnnotationContent.js';

function YAxisAnnotations({
  axis = 'y',
  annotationsLookupTable,
  drawableWidth,
  ticks,
  yScale
}) {
  const [activeIndex, setActiveIndex] = useState(-1);
  const [ref, setRef] = useState(null);
  const {
    annotations
  } = useMemo(() => {
    const annotations = Object.keys(annotationsLookupTable).map(key => {
      const annotation = annotationsLookupTable[key];

      if (!isValueWithinDomain(Number(annotation.startKey), yScale.domain())) {
        return null;
      }

      if (annotation == null || annotation.axis == null || annotation.axis !== axis) {
        return null;
      }

      return annotation;
    }).filter(Boolean);
    return {
      annotations
    };
  }, [annotationsLookupTable, yScale, axis]);
  const {
    positions
  } = useYAxisAnnotationPositions({
    axis,
    annotations,
    drawableWidth,
    ticks,
    yScale
  });

  const handleOnMouseLeave = () => {
    setActiveIndex(-1);
  };

  useSVGBlurEvent({
    ref,
    onBlur: handleOnMouseLeave,
    checkFn: activeElement => {
      const focusedParent = activeElement === null || activeElement === void 0 ? void 0 : activeElement.parentElement;
      return (focusedParent === null || focusedParent === void 0 ? void 0 : focusedParent.dataset.isAnnotationContent) !== 'true';
    }
  });
  return /*#__PURE__*/jsx("g", {
    ref: setRef,
    tabIndex: -1,
    className: styles.Group,
    children: positions.map(position => {
      var _line$width;

      const index = position.index;
      const annotation = annotations[index];
      const {
        line,
        x,
        y
      } = position;
      const hasContent = annotation.content != null;
      const isContentVisible = index === activeIndex && hasContent;
      const tabIndex = index + 1;
      const ariaLabel = `${annotation.startKey}`;
      const axisLabelX = axis === 'y2' ? drawableWidth + Y_AXIS_CHART_SPACING : -Y_AXIS_CHART_SPACING;
      return /*#__PURE__*/jsxs(Fragment, {
        children: [position.showYAxisLabel && /*#__PURE__*/jsx(AnnotationYAxisLabel, {
          axis: axis,
          y: line.y,
          x: axisLabelX,
          label: annotation.startKey
        }), /*#__PURE__*/jsx(AnnotationLine, {
          direction: "horizontal",
          hasCaret: false,
          size: (_line$width = line.width) !== null && _line$width !== void 0 ? _line$width : 0,
          x: line.x,
          y: line.y
        }), /*#__PURE__*/jsx(AnnotationLabel, {
          ariaLabel: ariaLabel,
          hasContent: hasContent,
          index: index,
          isVisible: !isContentVisible,
          label: annotation.label,
          position: position,
          setActiveIndex: setActiveIndex,
          tabIndex: tabIndex
        }), isContentVisible && /*#__PURE__*/jsx(AnnotationContent, {
          annotation: annotation,
          drawableWidth: drawableWidth,
          index: index,
          onMouseLeave: handleOnMouseLeave,
          parentRef: ref,
          position: position,
          tabIndex: tabIndex,
          x: drawableWidth - (drawableWidth - x),
          y: y
        })]
      }, `annotation${index}${annotation.startKey}`);
    })
  });
}

export { YAxisAnnotations };
