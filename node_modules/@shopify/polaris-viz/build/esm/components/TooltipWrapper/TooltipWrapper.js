import { useState, useRef, useMemo, useEffect, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { useRootContainer } from '../../hooks/useRootContainer.js';
import { shouldBlockTooltipEvents } from './utilities/shouldBlockTooltipEvents.js';
import { DEFAULT_TOOLTIP_POSITION } from './constants.js';
import { TooltipAnimatedContainer } from './components/TooltipAnimatedContainer.js';
import { jsx } from 'react/jsx-runtime';
import { SwallowErrors } from '../SwallowErrors/SwallowErrors.js';

const TOOLTIP_ID = 'polaris_viz_tooltip_root';

function TooltipWrapperRaw(props) {
  const {
    alwaysUpdatePosition = false,
    bandwidth = 0,
    chartBounds,
    focusElementDataType,
    getAlteredPosition,
    getPosition,
    id,
    onIndexChange,
    parentRef,
    chartDimensions
  } = props;
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
    activeIndex: -1,
    position: DEFAULT_TOOLTIP_POSITION
  });
  const activeIndexRef = useRef(null);
  const focusElements = useMemo(() => {
    return parentRef === null || parentRef === void 0 ? void 0 : parentRef.querySelectorAll(`[data-type="${focusElementDataType}"][aria-hidden="false"]`);
  }, [focusElementDataType, parentRef]);
  useEffect(() => {
    activeIndexRef.current = position.activeIndex;
  }, [position.activeIndex]);
  const onMouseMove = useCallback(event => {
    const newPosition = getPosition({
      event,
      eventType: 'mouse'
    });

    if (alwaysUpdatePosition && (newPosition.x < chartBounds.x || newPosition.y < chartBounds.y)) {
      return;
    }

    if (!alwaysUpdatePosition && activeIndexRef.current === newPosition.activeIndex) {
      return;
    }

    if (shouldBlockTooltipEvents(event)) {
      return;
    }

    setPosition(newPosition);
    onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(newPosition.activeIndex);
  }, [alwaysUpdatePosition, chartBounds, getPosition, onIndexChange]);
  const onMouseLeave = useCallback(() => {
    onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(null);
    setPosition(prevState => {
      return { ...prevState,
        activeIndex: -1
      };
    });
  }, [onIndexChange]);
  const onFocus = useCallback(event => {
    const target = event.currentTarget;

    if (!target) {
      return;
    }

    const index = Number(target.dataset.index);
    const newPosition = getPosition({
      index,
      eventType: 'focus'
    });
    setPosition(newPosition);
    onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(newPosition.activeIndex);
  }, [getPosition, onIndexChange]);
  const onFocusIn = useCallback(() => {
    if (!(parentRef !== null && parentRef !== void 0 && parentRef.contains(document.activeElement))) {
      onMouseLeave();
    }
  }, [parentRef, onMouseLeave]);
  const setFocusListeners = useCallback(attach => {
    if (!focusElements) {
      return;
    }

    focusElements.forEach(el => {
      if (attach) {
        el.addEventListener('focus', onFocus);
      } else {
        el.removeEventListener('focus', onFocus);
      }
    });
  }, [focusElements, onFocus]);
  useEffect(() => {
    if (!parentRef) {
      return;
    }

    parentRef.addEventListener('mousemove', onMouseMove);
    parentRef.addEventListener('mouseleave', onMouseLeave);
    parentRef.addEventListener('touchmove', onMouseMove);
    parentRef.addEventListener('touchend', onMouseLeave);
    setFocusListeners(true);
    return () => {
      parentRef.removeEventListener('mousemove', onMouseMove);
      parentRef.removeEventListener('mouseleave', onMouseLeave);
      parentRef.removeEventListener('touchmove', onMouseMove);
      parentRef.removeEventListener('touchend', onMouseLeave);
      setFocusListeners(false);
    };
  }, [parentRef, onMouseMove, onMouseLeave, onFocus, setFocusListeners]);
  useEffect(() => {
    document.addEventListener('focusin', onFocusIn);
    return () => {
      document.removeEventListener('focusin', onFocusIn);
    };
  }, [parentRef, onFocusIn]);

  if (position.activeIndex == null || position.activeIndex < 0) {
    return null;
  }

  return /*#__PURE__*/jsx(TooltipAnimatedContainer, {
    activePointIndex: position.activeIndex,
    bandwidth: bandwidth,
    chartBounds: chartBounds,
    currentX: position.x,
    currentY: position.y,
    id: id,
    getAlteredPosition: getAlteredPosition,
    margin: props.margin,
    position: position.position,
    chartDimensions: chartDimensions,
    children: props.getMarkup(position.activeIndex)
  });
}

function TooltipWrapper({
  usePortal = false,
  ...props
}) {
  if (usePortal) {
    return /*#__PURE__*/jsx(TooltipWithPortal, { ...props
    });
  }

  return /*#__PURE__*/jsx(TooltipWithErrors, { ...props
  });
}

function TooltipWithErrors(props) {
  return /*#__PURE__*/jsx(SwallowErrors, {
    children: /*#__PURE__*/jsx(TooltipWrapperRaw, { ...props
    })
  });
}

function TooltipWithPortal(props) {
  const container = useRootContainer(TOOLTIP_ID);
  return /*#__PURE__*/createPortal( /*#__PURE__*/jsx(TooltipWithErrors, { ...props
  }), container);
}

export { TooltipWrapper };
