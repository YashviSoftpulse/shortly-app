import { memo, useRef, Fragment } from 'react';
import { useTheme, uniqueId } from '@shopify/polaris-viz-core';
import { groupNumbersIntoRuns } from './utilities/groupNumbersIntoRuns.js';
import { jsxs, jsx } from 'react/jsx-runtime';

function MissingDataAreaRaw({
  data,
  drawableHeight,
  xScale
}) {
  const selectedTheme = useTheme();
  const patternID = useRef(uniqueId('missingDataPattern'));
  const dataSeriesHasNulls = useRef(false);
  const dataLength = data[0].data.length - 1;
  const indexesWithData = new Set([]);

  for (const series of data) {
    const hasAnyNulls = series.data.some(({
      value
    }) => value == null);

    if (!hasAnyNulls) {
      continue;
    }

    for (const [index, {
      value
    }] of series.data.entries()) {
      if (value != null) {
        indexesWithData.add(index);
      } else {
        dataSeriesHasNulls.current = true;
      }
    }
  }

  if (indexesWithData.size === 0 || dataSeriesHasNulls.current === false) {
    return null;
  }

  const sortedIndexes = [...indexesWithData].sort((current, next) => current - next);
  const groups = groupNumbersIntoRuns(sortedIndexes);
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsxs("defs", {
      children: [/*#__PURE__*/jsx("pattern", {
        id: patternID.current,
        patternUnits: "userSpaceOnUse",
        width: "12",
        height: "12",
        patternTransform: "rotate(135)",
        children: /*#__PURE__*/jsx("line", {
          x1: "0",
          y: "0",
          x2: "0",
          y2: "12",
          stroke: selectedTheme.missingData.lineColor,
          strokeWidth: "12",
          opacity: "0.2"
        })
      }), /*#__PURE__*/jsxs("mask", {
        id: `${patternID.current}-clip`,
        children: [/*#__PURE__*/jsx("rect", {
          x: xScale(0),
          y: 0,
          height: drawableHeight,
          width: xScale(dataLength),
          fill: "white"
        }), groups.map((indexes, index) => {
          const startIndex = Math.min(...indexes);
          const endIndex = Math.max(...indexes);
          const width = xScale(endIndex - startIndex);
          return /*#__PURE__*/jsx("rect", {
            x: xScale(startIndex),
            y: 0,
            height: drawableHeight,
            width: width,
            fill: "black"
          }, index);
        })]
      })]
    }), /*#__PURE__*/jsx("rect", {
      x: xScale(0),
      y: 0,
      height: drawableHeight,
      width: xScale(dataLength),
      fill: `url(#${patternID.current})`,
      mask: `url(#${patternID.current}-clip)`
    })]
  });
}

const MissingDataArea = /*#__PURE__*/memo(MissingDataAreaRaw);

export { MissingDataArea };
