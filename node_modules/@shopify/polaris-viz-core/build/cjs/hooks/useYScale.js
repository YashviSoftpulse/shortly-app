'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var d3Scale = require('d3-scale');
var d3Array = require('d3-array');
var constants = require('../constants.js');
var useChartContext = require('./useChartContext.js');
var shouldRoundScaleUp = require('../utilities/shouldRoundScaleUp.js');
var estimateStringWidth = require('../utilities/estimateStringWidth.js');

const MINIMAL_LABEL_SPACE = 80;
function useYScale({
  drawableHeight,
  formatYAxisLabel,
  integersOnly = false,
  max,
  min,
  shouldRoundUp = true,
  verticalOverflow = true,
  fixedWidth,
  maxYOverride
}) {
  const {
    characterWidths
  } = useChartContext.useChartContext();

  if (maxYOverride != null && maxYOverride < 0) {
    throw new Error('maxYOverride must be a non-negative number.');
  }

  const [minY, maxY] = react.useMemo(() => {
    const isDataEmpty = min === 0 && max === 0;
    const minY = min;
    let maxY = isDataEmpty ? constants.DEFAULT_MAX_Y : max;

    if (maxYOverride != null && isDataEmpty) {
      maxY = maxYOverride;
    }

    if (integersOnly) {
      return [Math.floor(minY), Math.ceil(maxY)];
    }

    return [minY, maxY];
  }, [min, max, integersOnly, maxYOverride]);
  const {
    yScale,
    ticks,
    yAxisLabelWidth
  } = react.useMemo(() => {
    const maxTicks = Math.max(1, Math.ceil(drawableHeight / MINIMAL_LABEL_SPACE));
    const yScale = d3Scale.scaleLinear().range([drawableHeight, 0]).domain([Math.min(0, minY), Math.max(0, maxY)]); // if verticalOverflow is false, always round up
    // if verticalOverflow is true, only round up if both shouldRoundUp and shouldRoundScaleUp is true

    if (!verticalOverflow || shouldRoundUp && shouldRoundScaleUp.shouldRoundScaleUp({
      yScale,
      maxValue: maxY,
      maxTicks
    })) {
      yScale.nice(maxTicks);
    } else {
      const roundedDownMin = yScale.copy().nice(maxTicks).ticks(maxTicks)[0];
      yScale.domain([Math.min(roundedDownMin, minY), Math.max(0, maxY)]);
    }

    const filteredTicks = integersOnly ? yScale.ticks(maxTicks).filter(tick => Number.isInteger(tick)) : yScale.ticks(maxTicks);
    const ticks = filteredTicks.map(value => ({
      value,
      formattedValue: formatYAxisLabel(value),
      yOffset: yScale(value)
    }));
    const longestYAxisLabel = d3Array.maxIndex(ticks, ({
      formattedValue
    }) => formattedValue == null ? 0 : formattedValue.length);
    const text = ticks[longestYAxisLabel] ? ticks[longestYAxisLabel].formattedValue : '';
    const yAxisLabelWidth = estimateStringWidth.estimateStringWidth(text, characterWidths);
    return {
      yScale,
      ticks,
      yAxisLabelWidth
    };
  }, [verticalOverflow, shouldRoundUp, characterWidths, drawableHeight, formatYAxisLabel, integersOnly, maxY, minY]);
  return {
    yScale,
    ticks,
    yAxisLabelWidth: getLabelWidth(yAxisLabelWidth, fixedWidth)
  };
}
function getLabelWidth(yAxisLabelWidth, fixedWidth) {
  if (fixedWidth === false || fixedWidth == null) {
    return yAxisLabelWidth;
  }

  return fixedWidth;
}

exports.getLabelWidth = getLabelWidth;
exports.useYScale = useYScale;
