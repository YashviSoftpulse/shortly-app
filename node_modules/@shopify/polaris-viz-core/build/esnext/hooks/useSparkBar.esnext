import { scaleLinear, scaleBand } from 'd3-scale';
import { useMemo, useCallback } from 'react';
import { getGradientFromColor } from '../utilities/getGradientFromColor.esnext';

const STROKE_WIDTH = 1.5;
const BAR_PADDING = 0.3;
const MARGIN = 8;
const BAR_MIN_HEIGHT_RATIO = 0.5;

function calculateRange(data, height) {
  let hasNegatives;
  let hasPositives;

  for (const {
    value
  } of data) {
    if (value != null && value < 0) hasNegatives = true;else if (value != null && value > 0) hasPositives = true;
    if (hasNegatives && hasPositives) break;
  }

  let range = [height, MARGIN];

  if (hasNegatives && hasPositives) {
    range = [height - MARGIN, MARGIN];
  } else if (hasNegatives) {
    range = [height - MARGIN, 0];
  }

  return range;
}

function removeNullValues(data) {
  if (data == null) {
    return [];
  }

  return data.data.filter(({
    value
  }) => typeof value === 'number').map(({
    value
  }) => value);
}

function useSparkBar({
  data,
  height,
  width,
  seriesColor,
  targetLine = {
    offsetLeft: 0,
    offsetRight: 0,
    value: 0
  }
}) {
  var _defaultData$color;

  const {
    offsetLeft: rawOffsetLeft = 0,
    offsetRight: rawOffsetRight = 0,
    value: targetValue = 0
  } = targetLine;
  const offsetLeft = Math.abs(rawOffsetLeft);
  const offsetRight = Math.abs(rawOffsetRight);
  const filteredData = removeNullValues(data[0]);
  const [defaultData] = data;
  const yScale = scaleLinear().range(calculateRange(defaultData.data, height)).domain([Math.min(...filteredData, targetValue, 0), Math.max(...filteredData, targetValue, 0)]);
  const targetLineYPosition = yScale(targetValue);
  const xScale = scaleBand().range([offsetLeft, width - offsetRight]).paddingInner(BAR_PADDING).domain(defaultData.data.map((_, index) => index.toString()));
  const barWidth = useMemo(() => xScale.bandwidth(), [xScale]);
  const strokeDashoffset = offsetLeft == null ? -(STROKE_WIDTH / 2) : -(STROKE_WIDTH / 2) - offsetLeft;
  const getBarHeight = useCallback(value => {
    const height = Math.abs(yScale(value) - yScale(0));
    return Math.max(height, BAR_MIN_HEIGHT_RATIO * barWidth);
  }, [barWidth, yScale]);
  const dataWithIndex = defaultData ? defaultData.data.map((value, index) => ({
    value,
    index
  })) : [];
  const colorToUse = (_defaultData$color = defaultData === null || defaultData === void 0 ? void 0 : defaultData.color) !== null && _defaultData$color !== void 0 ? _defaultData$color : seriesColor;
  const color = getGradientFromColor(colorToUse);
  return {
    dataWithIndex,
    color,
    strokeDashoffset,
    barWidth,
    getBarHeight,
    xScale,
    yScale,
    targetLineYPosition,
    targetLineX1: 0 - offsetLeft,
    targetLineX2: width + offsetRight
  };
}

export { useSparkBar };
