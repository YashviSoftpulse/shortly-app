import { useMemo, Fragment } from 'react';
import { BARS_TRANSITION_CONFIG, STROKE_WIDTH, STROKE_DOT_ARRAY_WIDTH } from '../../constants.esnext';
import { jsxs, jsx } from 'react/jsx-runtime';
import { useTheme } from '../../hooks/useTheme.esnext';
import { getSeriesColors } from '../../utilities/getSeriesColors.esnext';
import { usePolarisVizContext } from '../../hooks/usePolarisVizContext.esnext';
import { uniqueId } from '../../utilities/uniqueId.esnext';
import { useSparkBar } from '../../hooks/useSparkBar.esnext';
import { getAnimationTrail } from '../../utilities/getAnimationTrail.esnext';
import { LinearGradientWithStops } from '../LinearGradientWithStops/LinearGradientWithStops.esnext';
import { Bar } from '../Bar/Bar.esnext';

function SparkBarSeries({
  data,
  targetLine,
  height,
  shouldAnimate,
  useTransition,
  width,
  theme
}) {
  const selectedTheme = useTheme(theme);
  const [seriesColor] = getSeriesColors(1, selectedTheme);
  const {
    // eslint-disable-next-line id-length
    components: {
      Defs,
      Mask,
      G,
      Rect,
      Line
    },
    animated
  } = usePolarisVizContext();
  const AnimatedG = animated(G);
  const id = useMemo(() => uniqueId('sparkbar-series'), []);
  const clipId = useMemo(() => uniqueId('sparkbar-series-clip'), []);
  const {
    dataWithIndex,
    color,
    getBarHeight,
    strokeDashoffset,
    xScale,
    yScale,
    barWidth,
    targetLineYPosition,
    targetLineX1,
    targetLineX2
  } = useSparkBar({
    data,
    height,
    width,
    seriesColor,
    targetLine
  });
  const transitions = useTransition(dataWithIndex, {
    key: ({
      index
    }) => index,
    from: {
      height: 0
    },
    leave: {
      height: 0
    },
    enter: ({
      value: {
        value
      }
    }) => ({
      height: getBarHeight(value == null ? 0 : value)
    }),
    update: ({
      value: {
        value
      }
    }) => ({
      height: getBarHeight(value == null ? 0 : value)
    }),
    default: {
      immediate: !shouldAnimate
    },
    trail: shouldAnimate ? getAnimationTrail(dataWithIndex.length) : 0,
    config: BARS_TRANSITION_CONFIG
  });
  const hasTargetLine = targetLine != null && targetLine.value != null;
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(Defs, {
      children: /*#__PURE__*/jsx(LinearGradientWithStops, {
        id: id,
        gradient: color,
        gradientUnits: "userSpaceOnUse",
        y1: "100%",
        y2: "0%"
      })
    }), /*#__PURE__*/jsx(Mask, {
      id: clipId,
      children: /*#__PURE__*/jsx(AnimatedG, {
        opacity: hasTargetLine ? '0.9' : '1',
        children: transitions(({
          height: barHeight
        }, item, _transition, index) => {
          var _item$value$value;

          const xPosition = xScale(index.toString());
          const height = shouldAnimate ? barHeight : getBarHeight((_item$value$value = item.value.value) !== null && _item$value$value !== void 0 ? _item$value$value : 0);
          return /*#__PURE__*/jsx(Bar, {
            borderRadius: selectedTheme.bar.borderRadius,
            x: xPosition == null ? 0 : xPosition,
            yScale: yScale,
            value: item.value.value,
            width: barWidth,
            height: height,
            fill: "white"
          }, index);
        })
      })
    }), /*#__PURE__*/jsx(Rect, {
      fill: `url(#${id})`,
      width: width,
      height: height,
      mask: `url(#${clipId})`
    }), hasTargetLine ? /*#__PURE__*/jsx(Line, {
      stroke: selectedTheme.seriesColors.comparison,
      strokeWidth: STROKE_WIDTH,
      x1: targetLineX1,
      x2: targetLineX2,
      y1: targetLineYPosition,
      y2: targetLineYPosition,
      strokeLinecap: "round",
      opacity: "0.9",
      strokeDashoffset: strokeDashoffset,
      strokeDasharray: STROKE_DOT_ARRAY_WIDTH
    }) : null]
  });
}

export { SparkBarSeries };
