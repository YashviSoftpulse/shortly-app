import { useMemo, Fragment } from 'react';
import { line, area } from 'd3-shape';
import { SHAPE_ANIMATION_HEIGHT_BUFFER, COLOR_VISION_SINGLE_ITEM } from '../../constants.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import { usePolarisVizContext } from '../../hooks/usePolarisVizContext.js';
import { usePrevious } from '../../hooks/usePrevious.js';
import { useChartContext } from '../../hooks/useChartContext.js';
import { useTheme } from '../../hooks/useTheme.js';
import { curveStepRounded } from '../../utilities/curveStepRounded.js';
import { uniqueId } from '../../utilities/uniqueId.js';
import { getGradientFromColor } from '../../utilities/getGradientFromColor.js';
import { LinearGradientWithStops } from '../LinearGradientWithStops/LinearGradientWithStops.js';
import { AnimatedLine } from './components/AnimatedLine/AnimatedLine.js';
import { getColorVisionStylesForActiveIndex } from '../../utilities/getColorVisionStylesForActiveIndex.js';
import { AnimatedArea } from './components/AnimatedArea/AnimatedArea.js';
import { Area } from './components/Area/Area.js';
import { getColorVisionEventAttrs } from '../../utilities/getColorVisionEventAttrs.js';

const ANIMATION_DELAY = 200;
const SPARK_STROKE_WIDTH = 1.5;
function LineSeries({
  activeLineIndex = -1,
  data,
  hiddenIndexes = [],
  index: lineSeriesIndex = 0,
  svgDimensions,
  theme,
  type = 'default',
  xScale,
  yScale
}) {
  var _data$metadata$relate, _data$metadata, _data$width, _data$strokeDasharray, _data$styleOverride, _data$styleOverride$l;

  const index = (_data$metadata$relate = data === null || data === void 0 ? void 0 : (_data$metadata = data.metadata) === null || _data$metadata === void 0 ? void 0 : _data$metadata.relatedIndex) !== null && _data$metadata$relate !== void 0 ? _data$metadata$relate : lineSeriesIndex;
  const {
    // eslint-disable-next-line id-length
    components: {
      Defs,
      Mask,
      G,
      Rect,
      Path
    },
    animated
  } = usePolarisVizContext();
  const previousData = usePrevious(data);
  const {
    shouldAnimate
  } = useChartContext();
  const AnimatedGroup = animated(G);
  const color = data === null || data === void 0 ? void 0 : data.color;
  const selectedTheme = useTheme(theme);
  const isSparkChart = type === 'spark';
  const lineGenerator = line().x((_, index) => xScale == null ? 0 : xScale(index)).y(({
    value
  }) => yScale(value !== null && value !== void 0 ? value : 0)).defined(({
    value
  }) => value != null);
  const areaGenerator = area().x((_, index) => xScale(index)).y0(svgDimensions.height).y1(({
    value
  }) => yScale(value !== null && value !== void 0 ? value : 0)).defined(({
    value
  }) => value != null);

  if (selectedTheme.line.hasSpline) {
    lineGenerator.curve(curveStepRounded);
    areaGenerator.curve(curveStepRounded);
  }

  const lineShape = lineGenerator(data.data);
  const [lastLinePoint] = data.data.filter(({
    value
  }) => value != null).slice(-1);
  const lastLinePointCoordinates = (lastLinePoint === null || lastLinePoint === void 0 ? void 0 : lastLinePoint.value) != null ? {
    x: xScale(data.data.indexOf(lastLinePoint)),
    y: yScale(lastLinePoint.value)
  } : null;
  const areaPath = areaGenerator(data.data);
  const id = useMemo(() => uniqueId('line-series'), []);
  const immediate = !shouldAnimate;
  const lineGradientColor = getGradientFromColor(color);
  const isSolidLine = data.isComparison !== true;
  const solidLineDelay = isSolidLine ? index * ANIMATION_DELAY : 0;
  const delay = immediate ? 0 : solidLineDelay;

  const hasNulls = data => data === null || data === void 0 ? void 0 : data.data.some(({
    value
  }) => value == null);

  const dataIsValidForAnimation = !hasNulls(data) && !hasNulls(previousData) && data.data.length === (previousData === null || previousData === void 0 ? void 0 : previousData.data.length);
  const {
    y: lastY = 0
  } = lastLinePointCoordinates !== null && lastLinePointCoordinates !== void 0 ? lastLinePointCoordinates : {};
  const zeroLineData = data.data.map(dataPoint => ({ ...dataPoint,
    value: dataPoint.value === null ? null : 0
  }));

  if (lineShape == null || areaPath == null) {
    return null;
  }

  const strokeWidth = isSparkChart ? SPARK_STROKE_WIDTH : (_data$width = data.width) !== null && _data$width !== void 0 ? _data$width : selectedTheme.line.width;
  const strokeDasharray = (_data$strokeDasharray = data.strokeDasharray) !== null && _data$strokeDasharray !== void 0 ? _data$strokeDasharray : 'none';
  const PathHoverTargetSize = 15;
  const showArea = selectedTheme.line.hasArea && (data === null || data === void 0 ? void 0 : (_data$styleOverride = data.styleOverride) === null || _data$styleOverride === void 0 ? void 0 : (_data$styleOverride$l = _data$styleOverride.line) === null || _data$styleOverride$l === void 0 ? void 0 : _data$styleOverride$l.hasArea) !== false;
  const zeroLineY = yScale(0);
  return /*#__PURE__*/jsx(Fragment, {
    children: /*#__PURE__*/jsxs(AnimatedGroup, {
      opacity: 1,
      style: {
        display: hiddenIndexes.includes(index) ? 'none' : undefined
      },
      children: [/*#__PURE__*/jsxs(Defs, {
        children: [/*#__PURE__*/jsx(LinearGradientWithStops, {
          id: `line-${id}`,
          gradient: lineGradientColor,
          gradientUnits: "userSpaceOnUse",
          y1: "100%",
          y2: "0%"
        }), /*#__PURE__*/jsx(Mask, {
          id: `mask-${id}`,
          children: dataIsValidForAnimation ? /*#__PURE__*/jsx(AnimatedLine, {
            lastY: lastY,
            delay: delay,
            lineGenerator: lineGenerator,
            strokeWidth: strokeWidth,
            immediate: immediate,
            index: index,
            activeLineIndex: activeLineIndex,
            strokeDasharray: strokeDasharray,
            fromData: previousData,
            toData: data,
            zeroLineY: zeroLineY,
            zeroLineData: zeroLineData
          }) : /*#__PURE__*/jsx(Fragment, {
            children: /*#__PURE__*/jsx(Path, {
              d: lineShape,
              stroke: "white",
              strokeLinejoin: "round",
              strokeLinecap: "round",
              strokeWidth: strokeWidth,
              style: { ...getColorVisionStylesForActiveIndex({
                  activeIndex: activeLineIndex,
                  index
                }),
                strokeDasharray,
                strokeLinecap: 'round'
              }
            })
          })
        })]
      }), showArea && (dataIsValidForAnimation ? /*#__PURE__*/jsx(AnimatedArea, {
        areaGenerator: areaGenerator,
        fromData: previousData,
        toData: data,
        zeroLineData: zeroLineData,
        type: type,
        delay: delay,
        immediate: immediate
      }) : /*#__PURE__*/jsx(Area, {
        series: data,
        areaPath: areaPath,
        type: type
      })), /*#__PURE__*/jsx(Rect, {
        x: "0",
        y: (strokeWidth + SHAPE_ANIMATION_HEIGHT_BUFFER) * -1,
        width: svgDimensions.width,
        height: svgDimensions.height + strokeWidth * 2 + SHAPE_ANIMATION_HEIGHT_BUFFER,
        fill: data.isComparison ? selectedTheme.seriesColors.comparison : `url(#line-${id})`,
        mask: `url(#mask-${`${id}`})`,
        style: {
          pointerEvents: 'none'
        }
      }), /*#__PURE__*/jsx(Path, {
        d: lineShape,
        strokeWidth: PathHoverTargetSize,
        stroke: "transparent",
        fill: "none",
        ...getColorVisionEventAttrs({
          type: COLOR_VISION_SINGLE_ITEM,
          index
        })
      })]
    })
  });
}

export { LineSeries };
